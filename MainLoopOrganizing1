############
# for each iteration: 

#• Check for keyboard input.

#• Figure out if the player character is standing on a platform.

#• Update player location, enemies, platforms, power ups, etc.

#• Check for various collisions (e.g., between playerand enemies).

#• Update other game state and end of game.

#• Erase objects from the old position on the screen.

#• Redraw objects in the new position on the screen.

# sleep for a short time and loop again...
############

InitializeState:
	# Set up Game State
	# Initial State should == 1
	la $t1, GameState
	li $t2, 1 
	sw $t2, 0($t1)
	
	# 2. Set up MovingPlatformState
	la $t1, MovingPlatformState
	li $t2, 1 # patrol left == 1, right == 2
	sw $t2, 0($t1)
	
	# 3. Set up EnemieState
	la $t1, EnemieState
	li $t2, 2 # patrol left == 1, right == 2
	sw $t2, 0($t1)

	



mainLoop:
	
	
	# Check       State
	CheckState:
		# Check Main Character State
		la $t1, MainCharacterState
		lw $t2, 0($t1)
		
		# if == 0, next object
		# if == 1, Keep Jumping up ?
		# if == 2, keep falling down ?
		
	
		# Main Character Keep Falling
		# ...
		
		
		
		# Check 
DetectGroundS:
		# if MainCharacter's Coordinate Y == 63 or 51 or 39
		# if Y == 63, ground detected
		# if Y == 51, X in the range [14, 50]
		# then floating ground detected
		# if Y == 39, 
		
		
		# Get Main Character's Current Coordinate
		la $t1, MainCharacterCurrentAddress
		lw $t2, 0($t1)
		lw $t3, 4($t1)
		
		# IF FALLING RATE == 1
		# Y = Y + 1
		addi $t3, $t3,1
		
		
			# Check X = X - 1
			addi $t4, $t2, -1
			# Calculate Address
			move $a0, $t4
			move $a1, $t3
			jal CalculateAddress
			move $t4, $v0
				# Get t5 as the address
				lw $t5, 0($t4)
				li $t6, Black
				li $t7, PlatformGreen
				beq $t5, $t7, GroundDetected
				beq $t5, $t6, FallingState
			
		# Check X = X + 1
		# Get Main Character's Current Coordinate
		la $t1, MainCharacterCurrentAddress
		lw $t2, 0($t1)
		lw $t3, 4($t1)
		
		# IF FALLING RATE == 1
		# Y = Y + 1
		addi $t3, $t3,1
		addi $t4, $t2, 1
		
		# Calculate Address
		move $a0, $t2
		move $a1, $t3
		jal CalculateAddress
		move $t4, $v0
		
		lw $t5, 0($t4)
		li $t6, Black
		li $t7, PlatformGreen
		beq $t5, $t6, FallingState
		beq $t5, $t7, GroundDetected

		# jr $ra
######
GroundDetected:
	la $t1, Collison_with_Ground_Signal
	sw $zero, 0($t1)
	# jr $ra
		
############################		
		#keep Checking States
		
		
		
		
		
		
		
		
		
		
		
# check keyboard input
	Check_Keyboard_input:
		li $t9, 0xffff0000	
		lw $t8, 0($t9)
		beq $t8, 1, keypress_happened
	##
		j CheckState

		keypress_happened:
			lw $t2, 4($t9) 			# this assumes $t9 is set to 0xfff0000 from before
			beq $t2, 0x77, respond_to_w 	# ASCII code of 'w' is 0x77 or 119 in decimal
			beq $t2, 0x61, respond_to_a 	# ASCII code of 'a' is 0x61 or 97 in decimal
			#beq $t2, 0x73, respond_to_s 	# ASCII code of 's' is 0x73 or 115 in decimal
			beq $t2, 0x64, respond_to_d 	# ASCII code of 'd' is 0x64 or 100 in decimal
			beq $t2, 0x72, Restart 		# ASCII code of 'r' is 0x72 or 114 in decimal
			beq $t2, 0x71, QuitGame 	# ASCII code of 'q' is 0x71 or 113 in decimal
	# in the case of capital letters
			beq $t2, 0x57, respond_to_w 	# ASCII code of 'W' is 0x57 or 87 in decimal
			beq $t2, 0x41, respond_to_a 	# ASCII code of 'A' is 0x41 or 65 in decimal
			#beq $t2, 0x53, respond_to_s 	# ASCII code of 'S' is 0x53 or 83 in decimal
			beq $t2, 0x44, respond_to_d 	# ASCII code of 'D' is 0x44 or 68 in decimal
			beq $t2, 0x52, Restart 		# ASCII code of 'R' is 0x52 or 82 in decimal
			beq $t2, 0x51, QuitGame 	# ASCII code of 'Q' is 0x51 or 81 in decimal
	
	##################################### Check Keyboard Input Part		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	# Update player location, enemies, platforms, power ups, etc.
	
	# Check for various collisions (e.g., between playerand enemies).

	#• Update other game state and end of game.

	#• Erase objects from the old position on the screen.

	#• Redraw objects in the new position on the screen.
	Sleep: 
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop

	
	j END
	
	
	
	
#############################################	
	
Step1: # Check Game State
	# initial == 1;  win == 2; lose == 3
	la $t0, GameState
	lw $t1, 0($t0)
	
	beq $t1, 2, DrawYouWinPage
	beq $t1, 3, GameOverPage
	
	
	
	
Step2: # Update Moving Platform
	la $t0, MovingPlatformState
	lw $t1, 0($t0)
	
	beq $t1, 1, MovingPlatFormPatrolLeft
	beq $t1, 2, MovingPlatFormPatrolRight
	
MovingPlatFormPatrolLeft:
	# Erase and Redraw platform
		# jal Erase
		# updateCurrentCoordinate
		# jal drawmovingplatform
	
	# update the movingplatformState
		# CheckCollison?

	# branch to next step in mainloop
	j Step3
	
MovingPlatFormPatrolRight:
	# Erase and Redraw platform
		# jal Erase
		# updateCurrentCoordinate
		# jal drawmovingplatform
	
	# update the movingplatformState
		# CheckCollison?

	# branch to next step in mainloop
	j Step3


Step3: # Update Enemie
	la $t0, EnemieState
	lw $t1, 0($t0)
	
	# Patrol Left == 1
	# Patrol Right == 2
	
	beq $t1, 1, EnemiePatrolLeft
	beq $t1, 2, EnemiePatrolRight
	
EnemiePatrolLeft:
	# EraseEnemie
	
	# UpdateCurrentCoordinate to left
	
	# DrawEnemie
	
	# CheckCollison and Update Enemie State
	
	# Branch to next step
	j Step4

EnemiePatrolRight:	
		# EraseEnemie
	
	# UpdateCurrentCoordinate to right
	
	# DrawEnemie
	
	# CheckCollison and Update Enemie State
	
	# Branch to next step
	j Step4
	
	
	



Step4: # Update PickUps

	PU1:
	la $t0, PickUpState1
	lw $t1, 0($t0)
	
	# PickUpState == 4, Collected. Erase and set coordinate to [0,0]
	# PickUpState == 1, Hover Up
	# PickUpState == 2, Hover Down
	
	beq $t1, 1, HoverUp1
	beq $t1, 2, HoverDown1
	beq $t1, 4, Collected1
	# Write the 1.erase part in the collision detection part, also 2.set the coordinate to [0,0] there
	# 3. Update state to collected
	
	#Collected branch should do nothing and jump to next step directly

HoverUp1:	
	# ErasePickUp1
	
	# UpdateCurrentCoordinate to Up
	
	# DrawPickUp1
	
	# Update PickUp1 State
	
	# Branch to next step (Check for next pick Up)
	j PU2
	
	
	

HoverDown1:
	# ErasePickUp1
	
	# UpdateCurrentCoordinate to Down
	
	# DrawPickUp1
	
	
	# Update PickUp1 State
	
	# Branch to next step (Check for next pick Up)
	j PU2
	




Collected1:
	j PU2
	

PU2:
	la $t0, PickUpState2
	lw $t1, 0($t0)
	
	# PickUpState == 4, Collected. Erase and set coordinate to [0,0]
	# PickUpState == 1, Hover Up
	# PickUpState == 2, Hover Down
	
	beq $t1, 1, HoverUp2
	beq $t1, 2, HoverDown2
	beq $t1, 4, Collected2
	# Write the 1.erase part in the collision detection part, also 2.set the coordinate to [0,0] there
	# 3. Update state to collected
	
	#Collected branch should do nothing and jump to next step directly

HoverUp2:	
	# ErasePickUp2
	
	# UpdateCurrentCoordinate to Up
	
	# DrawPickUp1
	
	# Update PickUp1 State
	
	# Branch to next step (Check for next pick Up)
	j PU3
	
	
	

HoverDown2:
	# ErasePickUp2
	
	# UpdateCurrentCoordinate to Down
	
	# DrawPickUp2
	
	
	# Update PickUp2 State
	
	# Branch to next step (Check for next pick Up)
	j PU3
	




Collected2:
	j PU3
	
	
PU3:
	la $t0, PickUpState3
	lw $t1, 0($t0)
	
	# PickUpState == 4, Collected. Erase and set coordinate to [0,0]
	# PickUpState == 1, Hover Up
	# PickUpState == 2, Hover Down
	
	beq $t1, 1, HoverUp3
	beq $t1, 2, HoverDown3
	beq $t1, 4, Collected3
	# Write the 1.erase part in the collision detection part, also 2.set the coordinate to [0,0] there
	# 3. Update state to collected
	
	#Collected branch should do nothing and jump to next step directly

HoverUp3:	
	# ErasePickUp3
	
	# UpdateCurrentCoordinate to Up
	
	# DrawPickUp3
	
	# Update PickUp3 State
	
	# Branch to next step (Check for next pick Up)
	j Step5
	
	
	

HoverDown3:
	# ErasePickUp3
	
	# UpdateCurrentCoordinate to Down
	
	# DrawPickUp3
	
	
	# Update PickUp3 State
	
	# Branch to next step (Check for next pick Up)
	j Step5
	




Collected3:
	
	j Step5
	
	

Step5: # Detect Ground
	
DetectGroundS:
		# if MainCharacter's Coordinate Y == 63 or 51 or 39
		# if Y == 63, ground detected
		# if Y == 51, X in the range [14, 50]
		# then floating ground detected
		# if Y == 39, 
		
		
		# Get Main Character's Current Coordinate
		la $t1, MainCharacterCurrentAddress
		lw $t2, 0($t1)
		lw $t3, 4($t1)
		
		# IF FALLING RATE == 1
		# Y = Y + 1
		addi $t3, $t3,1
		
		
			# Check X = X - 1
			addi $t4, $t2, -1
			# Calculate Address
			move $a0, $t4
			move $a1, $t3
			jal CalculateAddress
			move $t4, $v0
				# Get t5 as the address
				lw $t5, 0($t4)
				li $t6, Black
				li $t7, PlatformGreen
				beq $t5, $t7, GroundDetected
				beq $t5, $t6, FallingState
			
		# Check X = X + 1
		# Get Main Character's Current Coordinate
		la $t1, MainCharacterCurrentAddress
		lw $t2, 0($t1)
		lw $t3, 4($t1)
		
		# IF FALLING RATE == 1
		# Y = Y + 1
		addi $t3, $t3,1
		addi $t4, $t2, 1
		
		# Calculate Address
		move $a0, $t2
		move $a1, $t3
		jal CalculateAddress
		move $t4, $v0
		
		lw $t5, 0($t4)
		li $t6, Black
		li $t7, PlatformGreen
		beq $t5, $t6, FallingState
		beq $t5, $t7, GroundDetected

		# jr $ra
######
GroundDetected:
	la $t1, Collison_with_Ground_Signal
	sw $zero, 0($t1)
	# jr $ra
		
############################		
	
	
	
	
	
	




Step6: # Check_Keyboard_input







Step7: # Detect_Collison_with_PickUps






Step8: # Detect Collision with Enemie







Step9: # Check if there is any signals or states 
	
	
	
	
	
Step10: # Sleep for a while and j back to mainLoop	
	Sleep: 
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop

	







########




respond_to_w:
#######################  Main Character Jump ###################
IFJUMP: 
# Check Ground
	la $t1, Collison_with_Ground_Signal
	lw $t6, 0($t1)
	# on_the_ground == 0 -> suspend respond_to_s;(no respond_to_s all the time?)
	# in the air, could double jump == 1 
	# has double jumped == 2 -> suspend respond_to_w
	beq $t6, 0, JUMP
	beq $t6, 1, DOUBLEJUMP
	# or next line in the mainloop
	beq $t6, 2, Sleep
	
	
JUMP:
	## Start Jumping ####
	
	# change the SIGNAL TO 1
	la $t1, Collison_with_Ground_Signal
	addi $t2, $zero, 1
	
	sw $t2, 0($t1)
	
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * JumpRate
	li $t5, JumpRate
	li $t0, -256
	mult $t0, $t5
	mflo $t5
	
	
	# the multiply for 2 part does not make sense.
	# li $t1, 2
	
	# mult $t5, $t2
	# mflo $t2
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END   
	# add $t2, $t6, $t2
	
	# Current Address of main character
	add $t6, $t6, $t5
	
	# Store the new main character address
	sw $t6, 0($t7)
	
	# Draw new main character
	
	jal DrawCharacter
	
	
	
	# Jump to the next line in the mainloop?
	j Sleep
	
	
DOUBLEJUMP:
	## Start Double Jumping ####
	
	# change the SIGNAL TO 2
	la $t1, Collison_with_Ground_Signal
	addi $t2, $zero, 2
	
	sw $t2, 0($t1)
	
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * JumpRate
	li $t5, JumpRate
	li $t0, -256
	mult $t0, $t5
	mflo $t5
	
	
	# the multiply for 2 part does not make sense.
	# li $t1, 2
	
	# mult $t5, $t2
	# mflo $t2
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END   
	# add $t2, $t6, $t2
	
	# Current Address of main character
	add $t6, $t6, $t5
	
	# Store the new main character address
	sw $t6, 0($t7)
	
	# Draw new main character
	
	jal DrawCharacter
	
	
	
	# Jump to the next line in the mainloop?
	j Sleep
	







# What Could Triger Falling State???
# if No Ground/ platform detected under the feet

### Thus No ground detected would be the triger.
### Keep detect ground at every loop??? in other words, 
#	Collision_with_Ground_Signal should be updated at every loop.




# if Jumped/ Double Jumped
# keep falling at falling rate until ground is detected, then go back to steady/ initial state.

# how to detect???
# Do we need to detect the after move position????
# Move left/ right/ first, then detect ground???
# Detect ground first, before keep falling???





######
#    MainCharacterState:	.word 	0
#  Initial/steady state == 0
# Jumping State == 1 --> detect up
# Falling State == 2 ----> detect down






FallingState:
	# Check downside collison
	CheckDownSide:
		# Check (X,Y) coordinates
		



	# if on the ground, set signal to == 0
	# and Branch to next line in mainLoop!!!
	
	# if collide with enemie or pick Ups: ---->
	
	
	
	
	

	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * FallingRate
	li $t5, FallingRate
	li $t0, 256
	
	mult $t0, $t5
	mflo $t5
	
	# Update Base Address AND (X,Y) coordinate!!!
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END
	
	# li $t2, MainCharacterMaxXonGround
	
	add $t6, $t6, $t5
	
	# bge $t6, $t2, Sleep
	
	sw $t6, 0($t7)
	# Draw new main character
	
	jal DrawCharacter
	
	# Jump to Next line in mainLoop
	j Sleep




#### Need to figure out the jumping logic and falling state and ground detection logic







