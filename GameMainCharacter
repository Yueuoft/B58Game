#####################################################################
#
# CSCB58 Winter 2024 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yue Li, 1004746091, liyue42, yuee.li@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4 (update this as needed)
# - Unit height in pixels: 4 (update this as needed)
# - Display width in pixels: 256 (update this as needed)
# - Display height in pixels: 256 (update this as needed)
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestones have been reached in this submission?
# (See the assignment handout for descriptions of the milestones)
# - Milestone 1/2/3/4 (choose the one the applies)
#
# Which approved features have been implemented for milestone 3?
# (See the assignment handout for the list of additional features)	5 minimum

#######
# 1. Moving objects (2 marks) 
#	[enemies patrol left and right across on the platform they are on; object pickups hovering gently up and down]
# 2. Moving platforms (2 marks)
# 3. Disappearing platforms (1 mark, 2 marks max if combining with moving platforms feature)
# 4. (different levels (2 marks)  [different configuration of platforms, enemies, and pickups, at least 3 levels]
# 	[Finishing a level” depends on your game design, for example:
#		collecting all pick-ups, killing all enemies, or reaching a specific platform]
# 5. Pick-up effects (2 marks): 
#	 Make the player jump higher? Make enemies bigger? Restore player health? 
#	Turn the player into a frog? Anything goes as long as at least 3 different effects. 
# 6. Double jump (1 mark): 
#	allow the player to jump when in mid-air, but only once!
# 7. start menu (1 mark)
#	[needs to be sophisticated enough]
#
#
# Link to video demonstration for final submission:
# - (insert YouTube / MyMedia / other URL here). Make sure we can view it!
#
# Are you OK with us sharing the video with people outside course staff?
# - yes / no / yes, and please share this project github link as well!
#
# Any additional information that the TA needs to know:
# - (write here, if any)
#
#####################################################################


# The assembly directive .eqv defines a numeric constant which you can use instead of writing the
# number manually (similar to #define in C, but much more primitive) You can use it to define
# common useful constants such as fixed addresses, colours, number of enemies, etc.








.eqv BASE_ADDRESS 	0x10008000

.eqv EnemieInitialAddress		16108
# Max address (X = 59, Y = 62) 63 - 1 - 3 = 59; 63 - 1 = 62; Width = 64 =>   16108
.eqv EnemieMaxPossibleBaseAddress	16108
# Min Address (X = 4, Y = 62) 		15888
.eqv EnemieMinPossibleBaseAddress	15888
# 
.eqv MainCharacterInitialAddress	15880
.eqv MainCharacterMaxXonGround		16116
.eqv MainCharacterMinXonGround		15880
.eqv MainCharacterMaxY			

.eqv PickUpsInitialAddresses




#  Each 4-byte value has the following structure: 0x00RRGGBB, where 00 are just zeros, RR is
# an 8-bit colour value for the red component, GG are the 8-bits for the green components, and BB are
# the 8-bits for the blue component. For example, 0x00000000 is black,0x00ff0000 is bright red,
# 0x0000ff00 is green, and 0x00ffff00 is yellow


.eqv Orange 				0x00ff7e00
.eqv BoundaryPink 			0x00ffa3b1
.eqv PlatformGreen 			0x00a8e61d
.eqv Black 				0x00000000
.eqv Yellow 				0x00fff200
.eqv CRLightBlue 			0x0099d9ea
.eqv CRLightGreen 			0x00d3f9bc
.eqv CRDarkGreen			0x0022b14c
.eqv EMGrey				0x00546d8e
.eqv EMRed				0x00ed1c24
.eqv EMdarkblue				0x002f3699


.eqv Sleeptime 	40

.eqv NumEnemies 		1
.eqv NumPickUps 		3
.eqv JumpHeight			12	# units
.eqv MaxTimeJumped		2	# time before Collide with platform
.eqv FallingRate		6
.eqv JumpRate			6
.eqv platformMovingRate		1	#unitFrameBuffer
.eqv EnemieMovingRate		1
.eqv MainCharacterMovingRate	2
.eqv PickUpHoverRate		1


.eqv HeightofMainCharacter	9



.eqv RowUnit		64
.eqv LBM 		16128		# (62*64+0)*4 = 16128
.eqv RBM		16124		#(62*64+63)*4 = 16124
.eqv GBM		16380		# (63*64+63)*4 = 16380




#####
.data

NumCollected: 	.word 	0
NumFilled:	.word	0
NumJumped:	.word	0





EnemieState:	.word	0
# Initial == 0 
# Patrol Right == 1
# Collision with wall == 2
# Patrol left == 3


PickUpState1:	.word	0
# == 
# == 1 ----> Erase ---> ScoreState + 1
PickUpState2:	.word	0
PickUpState3:	.word	0





ScoreState:	.word 	0
# Score == 0
# Score == 1	PaintScore1
# Score == 2	PaintScore2
# Score == 3	PaintScore3 --> GameState --> you win



######################
# Main Character 4 Signals:   

Collison_with_Ground_Signal:	.word 	0
# A[0]   Collison_with_Ground_Signal
# on_the_ground == 0 -> suspend respond_to_s;(no respond_to_s all the time?)
# in the air, could double jump == 1 
# has double jumped == 2 -> suspend respond_to_w


Collision_with_Wall_Signal:	.word	0
# A[1]   Collision_with_Wall_Signal
# no wall == 0 
# left_wall == 1 --> suspend respond_to_a
# right_Wall == 2 ---> suspend respond_to_d



Collision_with_Enemie_Signal:	.word	0
# A[2]   Collision_with_Enemie_Signal
# No == 0
#Yes == 1 ---> Red EFFECT --> GameOVer


Collision_with_PickUp_Signal:	.word	0
# A[3]   Collision_with_PickUp_Signal
# No == 0
# Yes == 1 ----> YellowEffect ----> NumCollected + 1 






MainCharacterState:	.word 0:4



GameState:	.word	1
# initial == 1; restart == 0; win == 2; lose == 3; quit == 4




MainCRCoordinateXY:	.word 0:2
PickUp1CoordinateXY:	.word 0:2
PickUp2Coordinate:	.word 0:2
PickUp3Coordinate:	.word 0:2
EnemieCoordinate:	.word 0:2
MovingPlatformXCoordinate:	.word 0:2
MovingPlatformYCoordinate:	.word 0
FloatingPlatformXCoordinate:	.word 0:2
FloatingPlatformCoordinate:	.word 0:2


MainCharacterCurrentAddress:	.word 0










####
.text 
.globl main

main:
	jal ClearScreenSetup
	
################################    BLOCK #1 -------->   DrawBoundaries

DrawBoundaries:
	# This Block of Code uses all temporary registers t0 - t7 to paint the four boundaries for now
	#	IT ENDS THE WHOLE PROGRAM after running FOR NOW
	
	
	# Draw the Upper Boundary to Pink
	li $t0, BASE_ADDRESS	
	li $t1, BoundaryPink
	# Draw the ground boundary (platform to green later [after drawing upper,left,right boundaries])
	li $t7, PlatformGreen
	# let t2 be the current address
	move $t2, $t0
	# endpoint for upper boundary painting
	addi $t3, $t2, 256
	# endpoint for left boundary painting	256 * 64 = 16384
	addi $t4, $t0, LBM
	# endpoint for right boundary painting
	addi $t5, $t0, RBM
	# endpoint for Ground Boundary painting
	addi $t6, $t0, GBM
	
PaintUpperBoundary:
	beq $t2, $t3, PaintLeftBoundary
	sw $t1, 0($t2) 	# paint the first (top-left) unit pink
	
	addi $t2, $t2, 4
	j PaintUpperBoundary
	
PaintLeftBoundary:
	# $t2 = $t0 + 256 at this time
	beq $t2, $t4, PaintRightBoundaryInitial
	sw $t1, 0($t2)			# paint row 1 column 0 to pink
	addi $t2, $t2, 256
	j PaintLeftBoundary

PaintRightBoundaryInitial:
	# $t2 = $t0 + LBM at this time 
	
	add $t2, $t0, 252
	
PaintRightBoundary:
	
	sw $t1, 0($t2)
	beq $t2, $t5, PaintGroundInitial
	addi $t2, $t2, 256
	
	j PaintRightBoundary
				
PaintGroundInitial:
	# start from current t2 + 4
	addi $t2, $t2, 4
	
PaintGround:
	sw $t7, 0($t2)
	beq $t2, $t6, InitialDrawEnemie
	
	addi $t2, $t2, 4
	j PaintGround
			
################ BLOCK #1 <----------------------------			
						
	
	
########################### Clear Screen Block ###################	

ClearScreenSetup:
	# Draw the Entire Screen to Black
	li $t0, BASE_ADDRESS	
	li $t7, Black
	li $t3, GBM
	move $t2, $zero
	move $t1, $t0
	
ClearScreen:
	bgt $t2, $t3, DoneClear
	
	add $t1, $t0, $t2
	sw $t7, 0($t1)
	addi $t2, $t2, 4
	
	j ClearScreen
DoneClear:
	jr $ra	
########################## Clear Screen Block ##########	
	
	
	
	
	
InitializeState:
	# DrawInitialScreen
	
	
	
	# Set up Game State
	la $t1, GameState
	li $t2, 1 
	sw $t2, 0($t1)
	
	# Set MainCharacterState
	la $t1, Collison_with_Ground_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_Wall_Signal
	sw $t2, 0($t1)
	
	la $t1, Collision_with_Enemie_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_PickUp_Signal
	sw $zero, 0($t1)
		
	# Set Enemie State
	la $t1, EnemieState
	li $t3, 3	# Patrol left
	sw $t3, 0($t1)	
				
	
	# Set PickUps States
	la $t1, PickUpState1
	sw $zero, 0($t1)
	
	la $t1, PickUpState2
	sw $zero, 0($t1)
	
	la $t1, PickUpState3
	sw $zero, 0($t1)
	
	# Set Moving Platform State
	
	
	
	
	
	
	# Set Score State
	la $t1, ScoreState
	sw $zero, 0($t1)
	
	
	
	
	
	

mainLoop:
	
	# check keyboard input
	Check_Keyboard_input:
		li $t9, 0xffff0000	
		lw $t8, 0($t9)
		beq $t8, 1, keypress_happened
	##
		j CheckState

		keypress_happened:
			lw $t2, 4($t9) 			# this assumes $t9 is set to 0xfff0000 from before
			beq $t2, 0x77, respond_to_w 	# ASCII code of 'w' is 0x77 or 119 in decimal
			beq $t2, 0x61, respond_to_a 	# ASCII code of 'a' is 0x61 or 97 in decimal
			beq $t2, 0x73, respond_to_s 	# ASCII code of 's' is 0x73 or 115 in decimal
			beq $t2, 0x64, respond_to_d 	# ASCII code of 'd' is 0x64 or 100 in decimal
			beq $t2, 0x72, Restart 		# ASCII code of 'r' is 0x72 or 114 in decimal
			beq $t2, 0x71, QuitGame 	# ASCII code of 'q' is 0x71 or 113 in decimal
	# in the case of capital letters
			beq $t2, 0x57, respond_to_w 	# ASCII code of 'W' is 0x57 or 87 in decimal
			beq $t2, 0x41, respond_to_a 	# ASCII code of 'A' is 0x41 or 65 in decimal
			beq $t2, 0x53, respond_to_s 	# ASCII code of 'S' is 0x53 or 83 in decimal
			beq $t2, 0x44, respond_to_d 	# ASCII code of 'D' is 0x44 or 68 in decimal
			beq $t2, 0x52, Restart 		# ASCII code of 'R' is 0x52 or 82 in decimal
			beq $t2, 0x51, QuitGame 	# ASCII code of 'Q' is 0x51 or 81 in decimal
	
	##################################### Check Keyboard Input Part
	
	# Check Main Character State
	CheckState:
		
	
	# Update player location, enemies, platforms, power ups, etc.
	
	# Check for various collisions (e.g., between playerand enemies).

	#• Update other game state and end of game.

	#• Erase objects from the old position on the screen.

	#• Redraw objects in the new position on the screen.
	Sleep: 
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop

	
	
	
	
	
	
	
	
	
	j END
########














	#(t0, t1 untouched for draw enemie
	# check keyboard input (q for now)
	jal Check_Keyboard_input
	
	# update enemie location (patrolling from right to left for now)
	li $t2, EnemieMovingRate
	addi $t3, $zero, 4
	mult $t2, $t3
	mflo $t2
	# $t1 = $ t1 - 4*(move rate)
	move $t7, $t1
	sub $t1, $t1, $t2
	# check for collision with the left wall (exit loop/ game if collide for now)
	li $t2, EnemieMinPossibleBaseAddress
	add $t2, $t2, $t0
	blt $t1, $t2, END
	
	# Erase current enemie
	# t7 be the old position base address (untouched for now)
	jal EraseCurrentEnemie
	
	
	
	
	# Draw new enemie
	jal DrawEnemie
	
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop
	



############
# for each iteration: 

#• Check for keyboard input.

#• Figure out if the player character is standing on a platform.

#• Update player location, enemies, platforms, power ups, etc.

#• Check for various collisions (e.g., between playerand enemies).

#• Update other game state and end of game.

#• Erase objects from the old position on the screen.

#• Redraw objects in the new position on the screen.

# sleep for a short time and loop again...
############









	##



END: 
	#exit program
	li $v0, 10
	syscall








respond_to_w:
respond_to_a:

respond_to_d:	
################# Main Character Move Right ##################

MoveRight:
	# Check if on the ground
	
	# Check if collide with wall
	
	# Check if collide with enemie
	
	# Check if collide with PickUps
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 4 * moveRate
	li $t5, MainCharacterMaxXonGround
	li $t0, BASE_ADDRESS
	add $t5, $t5, $t0
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# bgt $t6, $t5, END
	addi $t6, $t6, 8
	bge $t6, $t5, Restart
	sw $t6, 0($t7)
	# Draw new main character
	
	jal DrawCharacter
	
	j Sleep


###############################################################
	
respond_to_s:
Restart:
	jal ClearScreenSetup
	j main
	
QuitGame: 
	jal ClearScreenSetup
	j END

DrawInitialScreen:
	# 1.  Draw Boundaries 
	
	# 2. 


RandomNumberGenerator:
	li $v0, 42
	li $a0, 0
	li $a1, 28
	syscall

	
# For animations, we generally need to update the display between 20 to 60 times per second (we
# recommend sleeping for 40ms, at least initially, which is a 25Hz update rate). When developing your
# game, you may find it occasionally useful to set it to a very high number to help debugging. We
# recommend using a constant (.eqv) to make it easy to change the wait time.	

SleepOperation:
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall


# Game State Logic:
# 1. Initialize (Draw initial screen, set character and objects state, start main loop)
# 2. Ongoing	
# 3. Collision with enemy: -> Draw Game over Screen (State -> take r and q input, display NumCollected )
# 4. Restart -> initialize
# 5. NumFilled == 3  -> Draw you win Screen (take r and q input, display NumCollected)
# 6. Quit -> exit program (END)



FillScoreSquare:
	




#########  Main Character Drawing #############################----->

InitialDrawCharacter:
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	li $t0 BASE_ADDRESS
	li $t1, MainCharacterInitialAddress
	# Current Base Address = (initial address)
	add $t2, $t0, $t1
	la $t7, MainCharacterCurrentAddress
	sw $t2, 0($t7)
	
	jal DrawCharacter
	j InitializeState
	
DrawCharacter: 
	# t2 as the base address	
	la $t1, MainCharacterCurrentAddress
	lw $t2, 0($t1)
	
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	li $t0 BASE_ADDRESS
	# Draw Middle Line
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t6, -1024($t2)
	sw $t6, -1280($t2)
	sw $t6, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t6, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t6, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	jr $ra
	


######################################################<------------Main Character Drawing

########### Erase Main Character #########################

EraseMainCharacter: 
	# t2 as the base address	import this
	la $t1, MainCharacterCurrentAddress
	lw $t2, 0($t1)
	# Draw Middle Line
	li $t5, Black
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t5, -1024($t2)
	sw $t5, -1280($t2)
	sw $t5, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t5, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t5, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	jr $ra









################################






#################### Main Character Move Left ###############













##############################################################


##################### Block #2 ---------------->
# Used (t0 - t2; t5 - t7)

InitialDrawEnemie:
	# Get initial address, load into t0
	li $t2, EnemieInitialAddress
	li $t0, BASE_ADDRESS
	add $t1, $t0, $t2
	# Set the Current Base Address to Initial Base Address, store in t1
	
	
	# Base Address Possible Range [$gp + 15888,   $gp + 16108]
	
	
	jal DrawEnemie
	j InitialDrawCharacter
DrawEnemie:
	# Get Current Base Address 
	
	# Get Colors
	li $t7, EMGrey
	li $t6, EMRed
	li $t5, EMdarkblue
	# Draw Bottom layer (1)
	sw $t7, 0($t1)
	sw $t7, 8($t1)
	sw $t7, 12($t1)
	sw $t7, -8($t1)
	sw $t7, -12($t1)
	sw $t5, 4($t1)
	sw $t5, -4($t1)
	# Draw Layer (2)
	sw $t6, -252($t1)
	sw $t6, -260($t1)
	sw $t7, -248($t1)
	sw $t7, -264($t1)
	#  lw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t7, -516($t1)
	sw $t7, -508($t1)
	#lw $t7, 0($t1)     Black no need to draw
	
	# Draw Layer (4)
	sw $t7, -768($t1)
	
######### 	
	
	
	jr $ra
	
##########	Block #2 Works


######################### Erase Enemie -------------->

EraseCurrentEnemie:
	# t7 be the base address
	li $t6, Black
	# Erase Bottom layer (1)
	sw $t6, 0($t7)
	sw $t6, 8($t7)
	sw $t6, 12($t7)
	sw $t6, -8($t7)
	sw $t6, -12($t7)
	sw $t6, 4($t7)
	sw $t6, -4($t7)
	# Erase Layer (2)
	sw $t6, -252($t7)
	sw $t6, -260($t7)
	sw $t6, -248($t7)
	sw $t6, -264($t7)
	#  sw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t6, -516($t7)
	sw $t6, -508($t7)
	#s w$t7, 0($t1)     Black no need to draw
	
	# Erase Layer (4)
	sw $t6, -768($t7)
	
	jr $ra
	
##################################    Erase Enemie ######### <-------------------	















DrawPickup:






DrawMovingPlatform:





DrawMiddlePlatform:




DrawYouWinScreen:




DrawGameOverScreen:




# JumpHeight

# Collide with ground



##
#	Enemie State:
#	1. Initial
#	2. Patrol left -> (detect Wall) -> 3
#		Patrol left -> Collision with MainCharacter -> GameOver
#	3. Patrol right -> (detect Wall) ->2
#		Patrol right -> Collision with MainCharacter -> Gameover



##
#	PickUp State:
#	1. initial State
#	2. Hover Up -> 3
#		Hover Up -> (Collision with MainCharacter -> 4)
#	3. Hover Down - > 2
#		Hover Down -> (Collision with MainCharacter -> 4)
#	4. Disappear (Erase) ---> Score +1 --> Fill ScoreSquare 
#		



## 
#	ScoreSquare State:
#	1. NumFilled == 0
#	2. NumFilled == 1
#	3. NumFilled == 2
#	4. NumFilled == 3 ---> You Win State, display score
#
#


##	
#	MovingPlatformState:
#	1. Initial State == initial address
#	2. MovingLeft --> move with movingRate
#	3. MovingRight ---> move with MovingRate
#	4. Steady state
#


##
#	MainCharacterState:
#	1. InitialState == initial address + initialDraw
#	2. SteadyState
#	3. MoveLeft	moverate
#	4. MoveRight 
#	5. Jumping	CurrentAddress + jumprate
#	6. DoubleJump   CurrentAddress + jumpRate
#	7. FallingState    
#	[if no platform detected!!] ---> (gravity) falling down ---> what about land on Enemie????
#	8. CollideWithPlatform --> 2. steadyState
#	9. CollideWithEnemie --> ChangeColorVariation(TurnRed) + GameOverState
#	10. CollideWithPickUps ---> ChangeColorVariation(TurnYellow) ---> ChangeColorBack+ steady?
#

# MovingPlatform to top = 36 units 27 /2 = 13 
# height of main character = 9 units
# 


