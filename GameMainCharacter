#####################################################################
#
# CSCB58 Winter 2024 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yue Li, 1004746091, liyue42, yuee.li@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4 (update this as needed)
# - Unit height in pixels: 4 (update this as needed)
# - Display width in pixels: 256 (update this as needed)
# - Display height in pixels: 256 (update this as needed)
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestones have been reached in this submission?
# (See the assignment handout for descriptions of the milestones)
# - Milestone 1/2/3/4 (choose the one the applies)
#
# Which approved features have been implemented for milestone 3?
# (See the assignment handout for the list of additional features)	5 minimum

#######
# 1. Moving objects (2 marks) 
#	[enemies patrol left and right across on the platform they are on; object pickups hovering gently up and down]
# 2. Moving platforms (2 marks)
# 3. Disappearing platforms (1 mark, 2 marks max if combining with moving platforms feature)
# 4. (different levels (2 marks)  [different configuration of platforms, enemies, and pickups, at least 3 levels]
# 	[Finishing a level” depends on your game design, for example:
#		collecting all pick-ups, killing all enemies, or reaching a specific platform]
# 5. Pick-up effects (2 marks): 
#	 Make the player jump higher? Make enemies bigger? Restore player health? 
#	Turn the player into a frog? Anything goes as long as at least 3 different effects. 
# 6. Double jump (1 mark): 
#	allow the player to jump when in mid-air, but only once!
# 7. start menu (1 mark)
#	[needs to be sophisticated enough]
#
#
# Link to video demonstration for final submission:
# - (insert YouTube / MyMedia / other URL here). Make sure we can view it!
#
# Are you OK with us sharing the video with people outside course staff?
# - yes / no / yes, and please share this project github link as well!
#
# Any additional information that the TA needs to know:
# - (write here, if any)
#
#####################################################################


# The assembly directive .eqv defines a numeric constant which you can use instead of writing the
# number manually (similar to #define in C, but much more primitive) You can use it to define
# common useful constants such as fixed addresses, colours, number of enemies, etc.








.eqv BASE_ADDRESS 	0x10008000

.eqv EnemieInitialAddress		16108
# Max address (X = 59, Y = 62) 63 - 1 - 3 = 59; 63 - 1 = 62; Width = 64 =>   16108
.eqv EnemieMaxPossibleBaseAddress	16108
# Min Address (X = 4, Y = 62) 		15888
.eqv EnemieMinPossibleBaseAddress	15888
# 
.eqv MainCharacterInitialAddress	15912
.eqv MainCharacterMaxXonGround		16116
.eqv MainCharacterMinXonGround		15880
# 
.eqv MainCharacterMaxY						

# .eqv PickUpsInitialAddresses











#  Each 4-byte value has the following structure: 0x00RRGGBB, where 00 are just zeros, RR is
# an 8-bit colour value for the red component, GG are the 8-bits for the green components, and BB are
# the 8-bits for the blue component. For example, 0x00000000 is black,0x00ff0000 is bright red,
# 0x0000ff00 is green, and 0x00ffff00 is yellow


.eqv Orange 				0x00ff7e00
.eqv BoundaryPink 			0x00ffa3b1
.eqv PlatformGreen 			0x00a8e61d
.eqv Black 				0x00000000
.eqv Yellow 				0x00fff200
.eqv CRLightBlue 			0x0099d9ea
.eqv CRLightGreen 			0x00d3f9bc
.eqv CRDarkGreen			0x0022b14c
.eqv EMGrey				0x00546d8e
.eqv EMRed				0x00ed1c24
.eqv EMdarkblue				0x002f3699


.eqv Sleeptime 	40

.eqv NumEnemies 		1
.eqv NumPickUps 		3
.eqv JumpHeight			12	# units
.eqv MaxTimeJumped		2	# time before Collide with platform
.eqv FallingRate		1
.eqv JumpRate			12
.eqv platformMovingRate		1	#unitFrameBuffer
.eqv EnemieMovingRate		1
.eqv MainCharacterMovingRate	2
.eqv PickUpHoverRate		1


.eqv HeightofMainCharacter	9



.eqv RowUnit		64
.eqv LBM 		16128		# (62*64+0)*4 = 16128
.eqv RBM		16124		#(62*64+63)*4 = 16124
.eqv GBM		16380		# (63*64+63)*4 = 16380




#####
.data

NumCollected: 	.word 	0
NumFilled:	.word	0
NumJumped:	.word	0





EnemieState:	.word	0
# Initial == 0 
# Patrol Right == 1
# Collision with wall == 2
# Patrol left == 3


PickUpState1:	.word	0
# == 
# == 1 ----> Erase ---> ScoreState + 1
PickUpState2:	.word	0
PickUpState3:	.word	0





ScoreState:	.word 	0
# Score == 0
# Score == 1	PaintScore1
# Score == 2	PaintScore2
# Score == 3	PaintScore3 --> GameState --> you win



######################
# Main Character 4 Signals:   

Collison_with_Ground_Signal:	.word 	0
# A[0]   Collison_with_Ground_Signal
# on_the_ground == 0 -> suspend respond_to_s;(no respond_to_s all the time?)
# in the air, could double jump == 1 
# has double jumped == 2 -> suspend respond_to_w


Collision_with_Wall_Signal:	.word	0
# A[1]   Collision_with_Wall_Signal
# no wall == 0 
# left_wall == 1 --> suspend respond_to_a
# right_Wall == 2 ---> suspend respond_to_d



Collision_with_Enemie_Signal:	.word	0
# A[2]   Collision_with_Enemie_Signal
# No == 0
#Yes == 1 ---> Red EFFECT --> GameOVer


Collision_with_PickUp_Signal:	.word	0
# A[3]   Collision_with_PickUp_Signal
# No == 0
# Yes == 1 ----> YellowEffect ----> NumCollected + 1 






MainCharacterState:	.word 	0
#  Initial/steady state == 0
# Jumping State == 1 --> detect up
# Falling State == 2 ----> detect down



GameState:	.word	1
# initial == 1; restart == 0; win == 2; lose == 3; quit == 4



# [0-63, 0-63] 
# Address = 
MainCRCoordinateXY:	.word 0:2


PickUp1CoordinateXY:	.word 23 50
# [23, 50]

PickUp2CoordinateXY:	.word 36 50
# [36, 50]

PickUp3CoordinateXY:	.word	55 38
# [55, 38]

EnemieInitialCoordinate:	.word 	32 63
EnemieCurrentCoordinate:	.word 	32 63
EnemieLeftMostCoordinate:	.word	18 63
EnemieRightMostCoordinate:	.word	47 63


# Range (Same as FLOATING PLATFORM)???
# base / central address
# [18, 63] ----[47, 63]
#



MovingPlatformInitialCoordinateA:	.word 48 39
# [48, 40]----[61, 40]
# Length == 14
MovingPlatformInitialCoordinateB:	.word 61 39


MovingPlatformEndCoordinateA:	.word 	43 39
# [43, 40]------[56,40]
# Length == 14
MovingPlatformEndCoordinateB:	.word	56 39

# MovingPlatformInitial [48, 40] ---- [61, 40]   length = 14
# MovingPlatformEndRange [ 44, 40] ------[56, 40]   length = 14

MovingPlatformCurrentCoordinateA:	.word 48 39

MovingPlatformCurrentCoordinateB:	.word 61 39




FloatingPlatformXCoordinate:	.word 15 51
# [15,52] ----[49, 52]    Length == 35

FloatingPlatformENDCoordinate:	.word 49 51

FloatingPlatformLength:		.word 35


MainCharacterCurrentAddress:	.word 8 63



# IF Main Character's X coordinate less than or equal to 3, detect collision_with_left_wall
LeftWallBoundaryCoordinate:	.word 3

# IF Main Character's X coordinate is greater than or equal to 62, collision_with_right_wall detected
RightWallBoundaryCoordinate:	.word 62


ScoreBoxCoordinate:	.word	
# [2, 2]        [7,2]		[12,2]		[17,2]
# [2, 7]	[7,7]		[12,7]		[17,7]

ScoreBoxCoordinate1:	.word	2 2
ScoreBoxCoordinate2:	.word	17 2
ScoreBoxCoordinate3:	.word	2 7
ScoreBoxCoordinate4:	.word	17 7
ScoreBoxCoordinate5:	.word	7 2
ScoreBoxCoordinate6:	.word	7 7
ScoreBoxCoordinate7:	.word	12 2
ScoreBoxCoordinate8:	.word	12 7


FillScoreBox1Coordinate:	.word
#	[3,3]	[6 3]

#	[3,6]	[6,6]
FillScoreBox2Coordinate:	.word
#	[8,3]	[11,3]

#	[8,6]	[11,6]

FillScoreBox3Coordinate:	.word
#	[13,3]	[16,3]

#	[13,6]	[16,6]



####
.text 
.globl main

main:
	jal ClearScreenSetup
	
################################    BLOCK #1 -------->   DrawBoundaries

DrawBoundaries:
	# This Block of Code uses all temporary registers t0 - t7 to paint the four boundaries for now
	#	IT ENDS THE WHOLE PROGRAM after running FOR NOW
	
	
	# Draw the Upper Boundary to Pink
	li $t0, BASE_ADDRESS	
	li $t1, BoundaryPink
	# Draw the ground boundary (platform to green later [after drawing upper,left,right boundaries])
	li $t7, PlatformGreen
	# let t2 be the current address
	move $t2, $t0
	# endpoint for upper boundary painting
	addi $t3, $t2, 256
	# endpoint for left boundary painting	256 * 64 = 16384
	addi $t4, $t0, LBM
	# endpoint for right boundary painting
	addi $t5, $t0, RBM
	# endpoint for Ground Boundary painting
	addi $t6, $t0, GBM
	
PaintUpperBoundary:
	beq $t2, $t3, PaintLeftBoundary
	sw $t1, 0($t2) 	# paint the first (top-left) unit pink
	
	addi $t2, $t2, 4
	j PaintUpperBoundary
	
PaintLeftBoundary:
	# $t2 = $t0 + 256 at this time
	beq $t2, $t4, PaintRightBoundaryInitial
	sw $t1, 0($t2)			# paint row 1 column 0 to pink
	addi $t2, $t2, 256
	j PaintLeftBoundary

PaintRightBoundaryInitial:
	# $t2 = $t0 + LBM at this time 
	
	add $t2, $t0, 252
	
PaintRightBoundary:
	
	sw $t1, 0($t2)
	beq $t2, $t5, PaintGroundInitial
	addi $t2, $t2, 256
	
	j PaintRightBoundary
				
PaintGroundInitial:
	# start from current t2 + 4
	addi $t2, $t2, 4
	
PaintGround:
	sw $t7, 0($t2)
	beq $t2, $t6, DrawMiddlePlatform
	
	addi $t2, $t2, 4
	j PaintGround
			
################ BLOCK #1 <----------------------------			
						
	
	
########################### Clear Screen Block ###################	

ClearScreenSetup:
	# Draw the Entire Screen to Black
	li $t0, BASE_ADDRESS	
	li $t7, Black
	li $t3, GBM
	move $t2, $zero
	move $t1, $t0
	
ClearScreen:
	bgt $t2, $t3, DoneClear
	
	add $t1, $t0, $t2
	sw $t7, 0($t1)
	addi $t2, $t2, 4
	
	j ClearScreen
DoneClear:
	jr $ra	
########################## Clear Screen Block ##########	
	
	
	
	
	
InitializeState:
	# DrawInitialScreen
	
	
	
	# Set up Game State
	la $t1, GameState
	li $t2, 1 
	sw $t2, 0($t1)
	
	# Set MainCharacterState
	la $t1, Collison_with_Ground_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_Wall_Signal
	sw $t2, 0($t1)
	
	la $t1, Collision_with_Enemie_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_PickUp_Signal
	sw $zero, 0($t1)
		
	# Set Enemie State
	la $t1, EnemieState
	li $t3, 3	# Patrol left
	sw $t3, 0($t1)	
				
	
	# Set PickUps States
	la $t1, PickUpState1
	sw $zero, 0($t1)
	
	la $t1, PickUpState2
	sw $zero, 0($t1)
	
	la $t1, PickUpState3
	sw $zero, 0($t1)
	
	# Set Moving Platform State
	
	
	
	
	
	
	# Set Score State
	la $t1, ScoreState
	sw $zero, 0($t1)
	
	
	# Set Main Character State
	la $t1, MainCharacterState
	sw $zero, 0($t1)
	
	
	

mainLoop:
	
	# check keyboard input
	Check_Keyboard_input:
		li $t9, 0xffff0000	
		lw $t8, 0($t9)
		beq $t8, 1, keypress_happened
	##
		j CheckState

		keypress_happened:
			lw $t2, 4($t9) 			# this assumes $t9 is set to 0xfff0000 from before
			beq $t2, 0x77, respond_to_w 	# ASCII code of 'w' is 0x77 or 119 in decimal
			beq $t2, 0x61, respond_to_a 	# ASCII code of 'a' is 0x61 or 97 in decimal
			#beq $t2, 0x73, respond_to_s 	# ASCII code of 's' is 0x73 or 115 in decimal
			beq $t2, 0x64, respond_to_d 	# ASCII code of 'd' is 0x64 or 100 in decimal
			beq $t2, 0x72, Restart 		# ASCII code of 'r' is 0x72 or 114 in decimal
			beq $t2, 0x71, QuitGame 	# ASCII code of 'q' is 0x71 or 113 in decimal
	# in the case of capital letters
			beq $t2, 0x57, respond_to_w 	# ASCII code of 'W' is 0x57 or 87 in decimal
			beq $t2, 0x41, respond_to_a 	# ASCII code of 'A' is 0x41 or 65 in decimal
			#beq $t2, 0x53, respond_to_s 	# ASCII code of 'S' is 0x53 or 83 in decimal
			beq $t2, 0x44, respond_to_d 	# ASCII code of 'D' is 0x44 or 68 in decimal
			beq $t2, 0x52, Restart 		# ASCII code of 'R' is 0x52 or 82 in decimal
			beq $t2, 0x51, QuitGame 	# ASCII code of 'Q' is 0x51 or 81 in decimal
	
	##################################### Check Keyboard Input Part
	
	# Check       State
	CheckState:
		# Check Main Character State
		la $t1, MainCharacterState
		lw $t2, 0($t1)
		
		# if == 0, next object
		# if == 1, Keep Jumping up ?
		# if == 2, keep falling down ?
		
	
		# Main Character Keep Falling
		# ...
		
		
		
		# Check 
	DetectGroundS:
		# if MainCharacter's Coordinate Y == 63 or 51 or 39
		# if Y == 63, ground detected
		# if Y == 51, X in the range [14, 50]
		# then floating ground detected
		# if Y == 39, 
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	# Update player location, enemies, platforms, power ups, etc.
	
	# Check for various collisions (e.g., between playerand enemies).

	#• Update other game state and end of game.

	#• Erase objects from the old position on the screen.

	#• Redraw objects in the new position on the screen.
	Sleep: 
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop

	
	
	
	
	
	
	
	
	
	j END
########














	#(t0, t1 untouched for draw enemie
	# check keyboard input (q for now)
	jal Check_Keyboard_input
	
	# update enemie location (patrolling from right to left for now)
	li $t2, EnemieMovingRate
	addi $t3, $zero, 4
	mult $t2, $t3
	mflo $t2
	# $t1 = $ t1 - 4*(move rate)
	move $t7, $t1
	sub $t1, $t1, $t2
	# check for collision with the left wall (exit loop/ game if collide for now)
	li $t2, EnemieMinPossibleBaseAddress
	add $t2, $t2, $t0
	blt $t1, $t2, END
	
	# Erase current enemie
	# t7 be the old position base address (untouched for now)
	jal EraseCurrentEnemie
	
	
	
	
	# Draw new enemie
	jal DrawEnemie
	
	# sleep for a short time
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall
	
	# loop again
	j mainLoop
	
	END: 
	#exit program
	li $v0, 10
	syscall


############
# for each iteration: 

#• Check for keyboard input.

#• Figure out if the player character is standing on a platform.

#• Update player location, enemies, platforms, power ups, etc.

#• Check for various collisions (e.g., between playerand enemies).

#• Update other game state and end of game.

#• Erase objects from the old position on the screen.

#• Redraw objects in the new position on the screen.

# sleep for a short time and loop again...
############




CheckMainCharacterEnemieCollison:
	# Not Possible for Vertical Collison
	
	# if Y coordiate ==
	# & delta X coordinate less than or equal to 5 units == 5*4 = 20 offset difference
	# then collision happens
	




CheckMainCharacterPickUpCollision:
	
	
	
	
	
	
	
	
	
	
	




CheckGroundAndPlatforms:
	# Ground Coordinate
	
	
	# Floating Platform Coordinate
	
	
	# Moving Platform Coordinate










CheckLeftBoundary:
	# Left Boundary Coordinate
	




CheckRightBoundary:
	# Right Boundary Coordinate
	

























	##












respond_to_w:
#######################  Main Character Jump ###################
IFJUMP: 
# Check Ground
	la $t1, Collison_with_Ground_Signal
	lw $t6, 0($t1)
	# on_the_ground == 0 -> suspend respond_to_s;(no respond_to_s all the time?)
	# in the air, could double jump == 1 
	# has double jumped == 2 -> suspend respond_to_w
	beq $t6, 0, JUMP
	beq $t6, 1, DOUBLEJUMP
	# or next line in the mainloop
	beq $t6, 2, Sleep
	
	
JUMP:
	## Start Jumping ####
	
	# change the SIGNAL TO 1
	la $t1, Collison_with_Ground_Signal
	addi $t2, $zero, 1
	
	sw $t2, 0($t1)
	
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * JumpRate
	li $t5, JumpRate
	li $t0, -256
	mult $t0, $t5
	mflo $t5
	
	
	# the multiply for 2 part does not make sense.
	# li $t1, 2
	
	# mult $t5, $t2
	# mflo $t2
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END   
	# add $t2, $t6, $t2
	
	# Current Address of main character
	add $t6, $t6, $t5
	
	# Store the new main character address
	sw $t6, 0($t7)
	
	# Draw new main character
	
	jal DrawCharacter
	
	
	
	# Jump to the next line in the mainloop?
	j Sleep
	
	
DOUBLEJUMP:
	## Start Double Jumping ####
	
	# change the SIGNAL TO 2
	la $t1, Collison_with_Ground_Signal
	addi $t2, $zero, 2
	
	sw $t2, 0($t1)
	
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * JumpRate
	li $t5, JumpRate
	li $t0, -256
	mult $t0, $t5
	mflo $t5
	
	
	# the multiply for 2 part does not make sense.
	# li $t1, 2
	
	# mult $t5, $t2
	# mflo $t2
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END   
	# add $t2, $t6, $t2
	
	# Current Address of main character
	add $t6, $t6, $t5
	
	# Store the new main character address
	sw $t6, 0($t7)
	
	# Draw new main character
	
	jal DrawCharacter
	
	
	
	# Jump to the next line in the mainloop?
	j Sleep
	







# What Could Triger Falling State???
# if No Ground/ platform detected under the feet

### Thus No ground detected would be the triger.
### Keep detect ground at every loop??? in other words, 
#	Collision_with_Ground_Signal should be updated at every loop.




# if Jumped/ Double Jumped
# keep falling at falling rate until ground is detected, then go back to steady/ initial state.

# how to detect???
# Do we need to detect the after move position????
# Move left/ right/ first, then detect ground???
# Detect ground first, before keep falling???











FallingState:
	# Check downside collison
	CheckDownSide:
		# Check (X,Y) coordinates
		



	# if on the ground, set signal to == 0
	# and Branch to next line in mainLoop!!!
	
	# if collide with enemie or pick Ups: ---->
	
	
	
	
	

	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 256 * FallingRate
	li $t5, FallingRate
	li $t0, 256
	
	mult $t0, $t5
	mflo $t5
	
	# Update Base Address AND (X,Y) coordinate!!!
	
	
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END
	
	# li $t2, MainCharacterMaxXonGround
	
	add $t6, $t6, $t5
	
	# bge $t6, $t2, Sleep
	
	sw $t6, 0($t7)
	# Draw new main character
	
	jal DrawCharacter
	
	# Jump to Next line in mainLoop
	j Sleep












#################################################################








respond_to_a:
################# Main Character Move Left ##################

MoveLeft:
	# Check if on the ground
	
	# Check if collide with wall
	
	# Check if collide with enemie
	
	# Check if collide with PickUps
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 4 * moveRate
	li $t5, MainCharacterMinXonGround
	li $t0, BASE_ADDRESS
	add $t5, $t5, $t0
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# blt $t6, $t5, END
	addi $t6, $t6, -8
	ble $t6, $t5, Restart
	sw $t6, 0($t7)
	# Draw new main character
	
	jal DrawCharacter
	
	j Sleep


###############################################################





respond_to_d:	
################# Main Character Move Right ##################

MoveRight:
	# Check if on the ground
	
	# Check if collide with wall
	
	# Check if collide with enemie
	
	# Check if collide with PickUps
	
	# Erase Current Main Character
	jal EraseMainCharacter
	
	# Base Address =  current base address $t2 + 4 * moveRate
	li $t5, MainCharacterMaxXonGround
	li $t0, BASE_ADDRESS
	add $t5, $t5, $t0
	la $t7, MainCharacterCurrentAddress
	lw $t6, 0($t7)
	# bgt $t6, $t5, END
	addi $t6, $t6, 8
	bge $t6, $t5, Restart
	sw $t6, 0($t7)
	# Draw new main character
	
	jal DrawCharacter
	
	j Sleep


###############################################################
	
respond_to_s:
Restart:
	jal ClearScreenSetup
	j main
	
QuitGame: 
	jal ClearScreenSetup
	j END

DrawInitialScreen:
	# 1.  Draw Boundaries 
	
	# 2. 


RandomNumberGenerator:
	li $v0, 42
	li $a0, 0
	li $a1, 28
	syscall

	
# For animations, we generally need to update the display between 20 to 60 times per second (we
# recommend sleeping for 40ms, at least initially, which is a 25Hz update rate). When developing your
# game, you may find it occasionally useful to set it to a very high number to help debugging. We
# recommend using a constant (.eqv) to make it easy to change the wait time.	

SleepOperation:
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall


# Game State Logic:
# 1. Initialize (Draw initial screen, set character and objects state, start main loop)
# 2. Ongoing	
# 3. Collision with enemy: -> Draw Game over Screen (State -> take r and q input, display NumCollected )
# 4. Restart -> initialize
# 5. NumFilled == 3  -> Draw you win Screen (take r and q input, display NumCollected)
# 6. Quit -> exit program (END)




#######################
DrawScoreBox:
	






















FillScoreBox:
	




#########  Main Character Drawing #############################----->

InitialDrawCharacter:
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	li $t0 BASE_ADDRESS
	li $t1, MainCharacterInitialAddress
	# Current Base Address = (initial address)
	add $t2, $t0, $t1
	la $t7, MainCharacterCurrentAddress
	sw $t2, 0($t7)
	
	jal DrawCharacter
	j InitializeState
	
DrawCharacter: 
	# t2 as the base address	
	la $t1, MainCharacterCurrentAddress
	lw $t2, 0($t1)
	
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	li $t0 BASE_ADDRESS
	# Draw Middle Line
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t6, -1024($t2)
	sw $t6, -1280($t2)
	sw $t6, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t6, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t6, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	jr $ra
	


######################################################<------------Main Character Drawing

########### Erase Main Character #########################

EraseMainCharacter: 
	# t2 as the base address	import this
	la $t1, MainCharacterCurrentAddress
	lw $t2, 0($t1)
	# Draw Middle Line
	li $t5, Black
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t5, -1024($t2)
	sw $t5, -1280($t2)
	sw $t5, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t5, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t5, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	jr $ra









################################






#################### Main Character Move Left ###############













##############################################################


##################### Block #2 ---------------->
# Used (t0 - t2; t5 - t7)

InitialDrawEnemie:
	# Get initial address, load into t0
	li $t2, EnemieInitialAddress
	li $t0, BASE_ADDRESS
	add $t1, $t0, $t2
	# Set the Current Base Address to Initial Base Address, store in t1
	
	
	# Base Address Possible Range [$gp + 15888,   $gp + 16108]
	
	
	jal DrawEnemie
	j InitialDrawCharacter
DrawEnemie:
	# Get Current Base Address 
	
	# Get Colors
	li $t7, EMGrey
	li $t6, EMRed
	li $t5, EMdarkblue
	# Draw Bottom layer (1)
	sw $t7, 0($t1)
	sw $t7, 8($t1)
	sw $t7, 12($t1)
	sw $t7, -8($t1)
	sw $t7, -12($t1)
	sw $t5, 4($t1)
	sw $t5, -4($t1)
	# Draw Layer (2)
	sw $t6, -252($t1)
	sw $t6, -260($t1)
	sw $t7, -248($t1)
	sw $t7, -264($t1)
	#  lw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t7, -516($t1)
	sw $t7, -508($t1)
	#lw $t7, 0($t1)     Black no need to draw
	
	# Draw Layer (4)
	sw $t7, -768($t1)
	
######### 	
	
	
	jr $ra
	
##########	Block #2 Works


######################### Erase Enemie -------------->

EraseCurrentEnemie:
	# t7 be the base address
	li $t6, Black
	# Erase Bottom layer (1)
	sw $t6, 0($t7)
	sw $t6, 8($t7)
	sw $t6, 12($t7)
	sw $t6, -8($t7)
	sw $t6, -12($t7)
	sw $t6, 4($t7)
	sw $t6, -4($t7)
	# Erase Layer (2)
	sw $t6, -252($t7)
	sw $t6, -260($t7)
	sw $t6, -248($t7)
	sw $t6, -264($t7)
	#  sw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t6, -516($t7)
	sw $t6, -508($t7)
	#s w$t7, 0($t1)     Black no need to draw
	
	# Erase Layer (4)
	sw $t6, -768($t7)
	
	jr $ra
	
##################################    Erase Enemie ######### <-------------------	













##############################################3

InitialDrawPickup:

	la $t1, PickUp1CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)
	
	la $t1, PickUp2CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)

	la $t1, PickUp3CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)
	
	
	j InitialDrawEnemie
######################################
DrawPickUp:







##############################################

ErasePickUp:
	









###############################################

DrawMovingPlatformInitial:
	# Set up Platform length and Moving Ranges
	la $t1, MovingPlatformInitialCoordinateA
	# Load X coordinate
	lw $t2, 0($t1)
	# Load Y coordinate
	lw $t3, 4($t1)
	# Calculate Address
	move $a0, $t2
	move $a1, $t3

	jal CalculateAddress
	move $t4, $v0		
	
	# Get endpoint
	la $t5, MovingPlatformInitialCoordinateB
	# Load X coordinate
	lw $t6, 0($t5)
	# Load Y coordinate
	lw $t7, 4($t5)
	# Calculate Address
	move $a0, $t6
	move $a1, $t7
	jal CalculateAddress
	move $t0, $v0		
	
StartDrawingFlot: 

	li $t7, PlatformGreen
DrawFlotPlatI:
	bgt $t4, $t0, InitialDrawPickup
	sw $t7, 0($t4)
	
	addi $t4, $t4, 4
	j DrawFlotPlatI	
	
###################################################	
	
	
	
	
	
DrawMovingPlatform:
	# Get Current Coordinate
	la $t1, MovingPlatformCurrentCoordinateA
	
	# Load X coordinate
	lw $t2, 0($t1)
	# Load Y coordinate
	lw $t3, 4($t1)
	# Calculate Address
	move $a0, $t2
	move $a1, $t3

	jal CalculateAddress
	move $t4, $v0		
	
	
	# Get endpoint
	la $t5, MovingPlatformCurrentCoordinateB
	# Load X coordinate
	lw $t6, 0($t5)
	# Load Y coordinate
	lw $t7, 4($t5)
	# Calculate Address
	move $a0, $t6
	move $a1, $t7
	jal CalculateAddress
	move $t0, $v0		
	
	#StartDrawingFlot

	li $t7, PlatformGreen
DrawFlotPlat:
	bgt $t4, $t0, Sleep
	sw $t7, 0($t4)
	
	addi $t4, $t4, 4
	j DrawFlotPlat
	
##################################	
	
EraseANDdrawMovingPlatform:
	
	
	
	
	
	
	
	
	
	


###################################

DrawMiddlePlatform:
	# Set Up platform Length and Coordinates
	la $t1, FloatingPlatformXCoordinate
	# Load X coordinate
	lw $t2, 0($t1)
	# Load Y coordinate
	lw $t3, 4($t1)
	# Calculate Address
	move $a0, $t2
	move $a1, $t3

	jal CalculateAddress
	move $t4, $v0								
	# StartAddress in $t4
	
	


	# Get endpoint
	la $t5, FloatingPlatformENDCoordinate
	# Load X coordinate
	lw $t6, 0($t5)
	# Load Y coordinate
	lw $t7, 4($t5)
	# Calculate Address
	move $a0, $t6
	move $a1, $t7
	jal CalculateAddress
	move $t0, $v0					
	
	# Start Drawing
	li $t7, PlatformGreen
DrawMidPlat:
	bgt $t4, $t0, DrawMovingPlatformInitial
	sw $t7, 0($t4)
	
	addi $t4, $t4, 4
	j DrawMidPlat
	


#################################################

DrawYouWinScreen:
	la $t0, NumCollected
	lw $t1, 0($t0)
	# draw YOU WON!! and Score: Numcollected




DrawGameOverScreen:
	la $t0, NumCollected
	lw $t1, 0($t0)
	# draw game over and score : NumCollected
	
	
	
	
	
CalculateAddress: 
	# Take a0 = X and a1 = Y
	# Get Base Address
	li $t0, BASE_ADDRESS
	
	# offset = (Y * 64 + X )* 4
	addi $t1, $zero, 64
	mult $a1, $t1
	mflo $t1
	add $t1, $t1, $a0
	addi $t2, $zero, 4
	mult $t1, $t2
	mflo $t1
	
	add $t1, $t1, $t0
	move $v0, $t1

	jr $ra
	
	
	


# JumpHeight

# Collide with ground



##
#	Enemie State:
#	1. Initial
#	2. Patrol left -> (detect Wall) -> 3
#		Patrol left -> Collision with MainCharacter -> GameOver
#	3. Patrol right -> (detect Wall) ->2
#		Patrol right -> Collision with MainCharacter -> Gameover



##
#	PickUp State:
#	1. initial State
#	2. Hover Up -> 3
#		Hover Up -> (Collision with MainCharacter -> 4)
#	3. Hover Down - > 2
#		Hover Down -> (Collision with MainCharacter -> 4)
#	4. Disappear (Erase) ---> Score +1 --> Fill ScoreSquare 
#		



## 
#	ScoreSquare State:
#	1. NumFilled == 0
#	2. NumFilled == 1
#	3. NumFilled == 2
#	4. NumFilled == 3 ---> You Win State, display score
#
#


##	
#	MovingPlatformState:
#	1. Initial State == initial address
#	2. MovingLeft --> move with movingRate
#	3. MovingRight ---> move with MovingRate
#	4. Steady state
#


##
#	MainCharacterState:
#	1. InitialState == initial address + initialDraw
#	2. SteadyState
#	3. MoveLeft	moverate
#	4. MoveRight 
#	5. Jumping	CurrentAddress + jumprate
#	6. DoubleJump   CurrentAddress + jumpRate
#	7. FallingState    
#	[if no platform detected!!] ---> (gravity) falling down ---> what about land on Enemie????
#	8. CollideWithPlatform --> 2. steadyState
#	9. CollideWithEnemie --> ChangeColorVariation(TurnRed) + GameOverState
#	10. CollideWithPickUps ---> ChangeColorVariation(TurnYellow) ---> ChangeColorBack+ steady?
#

# MovingPlatform to top = 36 units 27 /2 = 13 
# height of main character = 9 units
# 

