

.eqv BASE_ADDRESS 	0x10008000

.eqv EnemieInitialAddress		16108
# Max address (X = 59, Y = 62) 63 - 1 - 3 = 59; 63 - 1 = 62; Width = 64 =>   16108
.eqv EnemieMaxPossibleBaseAddress	16108
# Min Address (X = 4, Y = 62) 		15888
.eqv EnemieMinPossibleBaseAddress	15888
# 
.eqv MainCharacterInitialAddress	15912
.eqv MainCharacterMaxXonGround		16116
.eqv MainCharacterMinXonGround		15880
# 
.eqv MainCharacterMaxY						

# .eqv PickUpsInitialAddresses











#  Each 4-byte value has the following structure: 0x00RRGGBB, where 00 are just zeros, RR is
# an 8-bit colour value for the red component, GG are the 8-bits for the green components, and BB are
# the 8-bits for the blue component. For example, 0x00000000 is black,0x00ff0000 is bright red,
# 0x0000ff00 is green, and 0x00ffff00 is yellow


.eqv Orange 				0x00ff7e00
.eqv BoundaryPink 			0x00ffa3b1
.eqv PlatformGreen 			0x00a8e61d
.eqv Black 				0x00000000
.eqv Yellow 				0x00fff200
.eqv CRLightBlue 			0x0099d9ea
.eqv CRLightGreen 			0x00d3f9bc
.eqv CRDarkGreen			0x0022b14c
.eqv EMGrey				0x00546d8e
.eqv EMRed				0x00ed1c24
.eqv EMdarkblue				0x002f3699


.eqv Sleeptime 	40

.eqv NumEnemies 		1
.eqv NumPickUps 		3
.eqv JumpHeight			12	# units
.eqv MaxTimeJumped		2	# time before Collide with platform
.eqv FallingRate		1
.eqv JumpRate			12
.eqv platformMovingRate		1	#unitFrameBuffer
.eqv EnemieMovingRate		1
.eqv MainCharacterMovingRate	2
.eqv PickUpHoverRate		1


.eqv HeightofMainCharacter	9



.eqv RowUnit		64
.eqv LBM 		16128		# (62*64+0)*4 = 16128
.eqv RBM		16124		#(62*64+63)*4 = 16124
.eqv GBM		16380		# (63*64+63)*4 = 16380




#####
.data

NumCollected: 	.word 	0
NumFilled:	.word	0
NumJumped:	.word	0




EnemieState:	.word	0
# Initial == 0 
# Patrol Right == 1
# Collision with wall == 2
# Patrol left == 3


PickUpState1:	.word	0
# == 
# == 1 ----> Erase ---> ScoreState + 1
PickUpState2:	.word	0
PickUpState3:	.word	0





ScoreState:	.word 	0
# Score == 0
# Score == 1	PaintScore1
# Score == 2	PaintScore2
# Score == 3	PaintScore3 --> GameState --> you win



######################
# Main Character 4 Signals:   

Collison_with_Ground_Signal:	.word 	0
# A[0]   Collison_with_Ground_Signal
# on_the_ground == 0 -> suspend respond_to_s;(no respond_to_s all the time?)
# in the air, could double jump == 1 
# has double jumped == 2 -> suspend respond_to_w


Collision_with_Wall_Signal:	.word	0
# A[1]   Collision_with_Wall_Signal
# no wall == 0 
# left_wall == 1 --> suspend respond_to_a
# right_Wall == 2 ---> suspend respond_to_d



Collision_with_Enemie_Signal:	.word	0
# A[2]   Collision_with_Enemie_Signal
# No == 0
#Yes == 1 ---> Red EFFECT --> GameOVer


Collision_with_PickUp_Signal:	.word	0
# A[3]   Collision_with_PickUp_Signal
# No == 0
# Yes == 1 ----> YellowEffect ----> NumCollected + 1 






MainCharacterState:	.word 	0
#  Initial/steady state == 0
# Jumping State == 1 --> detect up
# Falling State == 2 ----> detect down



GameState:	.word	1
# initial == 1; restart == 0; win == 2; lose == 3; quit == 4



# [0-63, 0-63] 
# Address = 
MainCRCoordinateXY:	.word 0:2


PickUp1CoordinateXY:	.word 22 50
# [23, 50]

PickUp2CoordinateXY:	.word 35 50
# [36, 50]

PickUp3CoordinateXY:	.word	54 38
# [55, 38]

EnemieInitialCoordinate:	.word 	31 62
EnemieCurrentCoordinate:	.word 	31 62
EnemieLeftMostCoordinate:	.word	17 62
EnemieRightMostCoordinate:	.word	46 62


# Range (Same as FLOATING PLATFORM)???
# base / central address
# [18, 63] ----[47, 63]

MainCharacterCurrentCoordinate:	.word 	4 62
MainCharacterInitialCoordinate:	.word	4 62




MovingPlatformInitialCoordinateA:	.word 48 39
# [48, 40]----[61, 40]
# Length == 14
MovingPlatformInitialCoordinateB:	.word 61 39


MovingPlatformEndCoordinateA:	.word 	43 39
# [43, 40]------[56,40]
# Length == 14
MovingPlatformEndCoordinateB:	.word	56 39

# MovingPlatformInitial [48, 40] ---- [61, 40]   length = 14
# MovingPlatformEndRange [ 44, 40] ------[56, 40]   length = 14

MovingPlatformCurrentCoordinateA:	.word 48 39

MovingPlatformCurrentCoordinateB:	.word 61 39




FloatingPlatformXCoordinate:	.word 14 51
# [15,52] ----[49, 52]    Length == 35

FloatingPlatformENDCoordinate:	.word 48 51

FloatingPlatformLength:		.word 35


MainCharacterCurrentAddress:	.word 7 62



# IF Main Character's X coordinate less than or equal to 3, detect collision_with_left_wall
LeftWallBoundaryCoordinate:	.word 2

# IF Main Character's X coordinate is greater than or equal to 62, collision_with_right_wall detected
RightWallBoundaryCoordinate:	.word 61


ScoreBoxCoordinate:	.word	
# [2, 2]        [7,2]		[12,2]		[17,2]
# [2, 7]	[7,7]		[12,7]		[17,7]

ScoreBoxCoordinate1:	.word	1 1
ScoreBoxCoordinate2:	.word	16 1
ScoreBoxCoordinate3:	.word	1 6
ScoreBoxCoordinate4:	.word	16 6
ScoreBoxCoordinate5:	.word	6 1
ScoreBoxCoordinate6:	.word	6 6
ScoreBoxCoordinate7:	.word	11 1
ScoreBoxCoordinate8:	.word	11 6


FillScoreBox1Coordinate:	.word	2 2
#	[3,3]	[6 3] ALL MINUS 1 !!!!!!!!!!!

#	[3,6]	[6,6]
FillScoreBox2Coordinate:	.word	7 2
#	[8,3]	[11,3]

#	[8,6]	[11,6]

FillScoreBox3Coordinate:	.word	12 2
#	[13,3]	[16,3]

#	[13,6]	[16,6]



###########################################################################################################
.text 
.globl main



###################################################################################### MAIN STARTS HERE
main:
	jal ClearScreenSetup
	
	# GAME INITIAL SET UP
	DrawInitialScreen:
	
	# Start With DrawBoundaries Block 
	# WHICH draws in the order of UpperLeftGround -----> then Branch to Draw MiddlePlatform Block
	# then branch to Draw Moving Platfrom Initial
	# THEN BRANCH TO InitialDrawScoreBox
	# Then Branch To Initial Draw PickUps
	# Then Branch To initial Draw Enemie 
	# Then Branch to initial Draw Character
	# Initial Drawing Finished 
	# NEXT, SET UP THE INITIAL STATES   
																				
													
################################    BLOCK #1 -------->   DrawBoundaries

DrawBoundaries:
	# This Block of Code uses all temporary registers t0 - t7 to paint the four boundaries for now
	#	IT ENDS THE WHOLE PROGRAM after running FOR NOW
	
	
	# Draw the Upper Boundary to Pink
	li $t0, BASE_ADDRESS	
	li $t1, BoundaryPink
	# Draw the ground boundary (platform to green later [after drawing upper,left,right boundaries])
	li $t7, PlatformGreen
	# let t2 be the current address
	move $t2, $t0
	# endpoint for upper boundary painting
	addi $t3, $t2, 256
	# endpoint for left boundary painting	256 * 64 = 16384
	addi $t4, $t0, LBM
	# endpoint for right boundary painting
	addi $t5, $t0, RBM
	# endpoint for Ground Boundary painting
	addi $t6, $t0, GBM
	
PaintUpperBoundary:
	beq $t2, $t3, PaintLeftBoundary
	sw $t1, 0($t2) 	# paint the first (top-left) unit pink
	
	addi $t2, $t2, 4
	j PaintUpperBoundary
	
PaintLeftBoundary:
	# $t2 = $t0 + 256 at this time
	beq $t2, $t4, PaintRightBoundaryInitial
	sw $t1, 0($t2)			# paint row 1 column 0 to pink
	addi $t2, $t2, 256
	j PaintLeftBoundary

PaintRightBoundaryInitial:
	# $t2 = $t0 + LBM at this time 
	
	add $t2, $t0, 252
	
PaintRightBoundary:
	
	sw $t1, 0($t2)
	beq $t2, $t5, PaintGroundInitial
	addi $t2, $t2, 256
	
	j PaintRightBoundary
				
PaintGroundInitial:
	# start from current t2 + 4
	addi $t2, $t2, 4
	
PaintGround:
	sw $t7, 0($t2)
	beq $t2, $t6, DrawMiddlePlatform
	
	addi $t2, $t2, 4
	j PaintGround
			
################ BLOCK #1 <----------------------------			
						
################################### BLOCK # 2------------------------------>

DrawMiddlePlatform:
	# Set Up platform Length and Coordinates
	la $t1, FloatingPlatformXCoordinate
	# Load X coordinate
	lw $t2, 0($t1)
	# Load Y coordinate
	lw $t3, 4($t1)
	# Calculate Address
	move $a0, $t2
	move $a1, $t3

	jal CalculateAddress
	move $t4, $v0								
	# StartAddress in $t4
	
	


	# Get endpoint
	la $t5, FloatingPlatformENDCoordinate
	# Load X coordinate
	lw $t6, 0($t5)
	# Load Y coordinate
	lw $t7, 4($t5)
	# Calculate Address
	move $a0, $t6
	move $a1, $t7
	jal CalculateAddress
	move $t0, $v0					
	
	# Start Drawing
	li $t7, PlatformGreen
DrawMidPlat:
	bgt $t4, $t0, DrawMovingPlatformInitial
	sw $t7, 0($t4)
	
	addi $t4, $t4, 4
	j DrawMidPlat
	


################################### BLOCK #2 <-----------------------------



################################ BLOCK # 3 ------------------------->

DrawMovingPlatformInitial:
	# Set up Platform length and Moving Ranges
	la $t1, MovingPlatformInitialCoordinateA
	# Load X coordinate
	lw $t2, 0($t1)
	# Load Y coordinate
	lw $t3, 4($t1)
	# Calculate Address
	move $a0, $t2
	move $a1, $t3

	jal CalculateAddress
	move $t4, $v0		
	
	# Get endpoint
	la $t5, MovingPlatformInitialCoordinateB
	# Load X coordinate
	lw $t6, 0($t5)
	# Load Y coordinate
	lw $t7, 4($t5)
	# Calculate Address
	move $a0, $t6
	move $a1, $t7
	jal CalculateAddress
	move $t0, $v0		
	
StartDrawingFlot: 

	li $t7, PlatformGreen
DrawFlotPlatI:
	bgt $t4, $t0, InitialDrawScoreBox
	sw $t7, 0($t4)
	
	addi $t4, $t4, 4
	j DrawFlotPlatI	


# Change from branch to initial draw pickup to DRAWSCOREBOX, THEN BRANCH TO INITIAL DRAW PICKUP FROM THERE.

################################# INITIAL DRAW OF MOVING PLATFORM <----------------


######################### Initial DRAW THE SCORE BOX ----------------->
# BRANCH HERE FROM INITIAL MOVING PLATFORM, AND BRANCH TO INITIALDRAWPICKUP AFTER DONE IT

InitialDrawScoreBox:
	la $t1, ScoreBoxCoordinate1
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate2
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->
	
	li $t0, Orange
StartPaintIB1:	
	bgt $t4, $t5, PaintIB2
	sw $t0, 0($t4)
	
	addi $t4, $t4, 4
	j StartPaintIB1
	
PaintIB2:
	la $t1, ScoreBoxCoordinate3
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate4
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->	
	li $t0, Orange
StartPaintIB2:	
	bgt $t4, $t5, PaintIBV1
	sw $t0, 0($t4)
	
	addi $t4, $t4, 4
	j StartPaintIB2
	
	# start paint vertical lines   FOUR(4) in total
PaintIBV1:
	la $t1, ScoreBoxCoordinate1
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate3
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->	
	li $t0, Orange
StartPaintIBV1:	
	bgt $t4, $t5, PaintIBV2
	sw $t0, 0($t4)
	
	addi $t4, $t4, 256
	j StartPaintIBV1
	
	
	
PaintIBV2:
	la $t1, ScoreBoxCoordinate5
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate6
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->	
	li $t0, Orange
StartPaintIBV2:	
	bgt $t4, $t5, PaintIBV3
	sw $t0, 0($t4)
	
	addi $t4, $t4, 256
	j StartPaintIBV2
		
		
PaintIBV3:
	la $t1, ScoreBoxCoordinate7
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate8
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->	
	li $t0, Orange
StartPaintIBV3:	
	bgt $t4, $t5, PaintIBV4
	sw $t0, 0($t4)
	
	addi $t4, $t4, 256
	j StartPaintIBV3
		
	

PaintIBV4:
	la $t1, ScoreBoxCoordinate2
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	# get the starting address and saved in $t4
	
	la $t1, ScoreBoxCoordinate4
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t5, $v0
	# Get the endpoint and paint -->	
	li $t0, Orange
StartPaintIBV4:	
	bgt $t4, $t5, InitialDrawPickup
	sw $t0, 0($t4)
	
	addi $t4, $t4, 256
	j StartPaintIBV4
		
	# BRANCH TO InitialDrawPickup AFTER
#############################  Initial SCORE BOX DRAWING <---------
	

######################## Initial Draw PickUps --------------->

InitialDrawPickup:

	la $t1, PickUp1CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)
	
	la $t1, PickUp2CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)

	la $t1, PickUp3CoordinateXY
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t4, $v0
	
	li $t5, Yellow
	sw $t5, 0($t4)
	sw $t5, -260($t4)
	sw $t5, -252($t4)
	sw $t5, -512($t4)
	sw $t5, -764($t4)
	sw $t5, -772($t4)
	
	
	j InitialDrawEnemie
################################### Initial Draw Pick Ups <------------





##################### Initial Draw Enemie  ---------------->

InitialDrawEnemie:
	
	la $t0, EnemieInitialCoordinate

	lw $t1, 0($t0)
	lw $t2, 4($t0)
	
	move $a0, $t1
	move $a1, $t2
	jal CalculateAddress
	move $t1, $v0
	
	
	# Get Colors
	li $t7, EMGrey
	li $t6, EMRed
	li $t5, EMdarkblue
	# Draw Bottom layer (1)
	sw $t7, 0($t1)
	sw $t7, 8($t1)
	sw $t7, 12($t1)
	sw $t7, -8($t1)
	sw $t7, -12($t1)
	sw $t5, 4($t1)
	sw $t5, -4($t1)
	# Draw Layer (2)
	sw $t6, -252($t1)
	sw $t6, -260($t1)
	sw $t7, -248($t1)
	sw $t7, -264($t1)
	#  lw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t7, -516($t1)
	sw $t7, -508($t1)
	#lw $t7, 0($t1)     Black no need to draw
	
	# Draw Layer (4)
	sw $t7, -768($t1)

	j InitialDrawCharacter
	
	# Branch to Initial Draw Character After it done
###############################  Initial Draw Enemie  <------------

################### Initial Draw Main Character ---------------->
InitialDrawCharacter:
	la $t1, MainCharacterInitialCoordinate
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t2, $v0

	# t2 as the base address	
	
	
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	
	# Draw Middle Line
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t6, -1024($t2)
	sw $t6, -1280($t2)
	sw $t6, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t6, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t6, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	
	j InitializeState

########################### Initial Draw Main Character <----------


# NEXT, INITIALIZE STATES###################################################################
# Still Game Setting Up
InitializeState:
	#j END
	# Set up Game State
	la $t1, GameState
	li $t2, 1 
	sw $t2, 0($t1)
	
	# Set MainCharacterState
	la $t1, Collison_with_Ground_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_Wall_Signal
	sw $t2, 0($t1)
	
	la $t1, Collision_with_Enemie_Signal
	sw $zero, 0($t1)
	
	la $t1, Collision_with_PickUp_Signal
	sw $zero, 0($t1)
		
	# Set Enemie State
	la $t1, EnemieState
	li $t3, 3	# Patrol left
	sw $t3, 0($t1)	
				
	
	# Set PickUps States
	la $t1, PickUpState1
	sw $zero, 0($t1)
	
	la $t1, PickUpState2
	sw $zero, 0($t1)
	
	la $t1, PickUpState3
	sw $zero, 0($t1)
	
	# Set Moving Platform State
	
	
	
	
	
	
	# Set Score State
	la $t1, ScoreState
	sw $zero, 0($t1)
	
	
	# Set Main Character State
	la $t1, MainCharacterState
	sw $zero, 0($t1)

	
	j END	
			
				
					
						
							
								
									
										
											
												
													
####################################################################### MainLoop Start HERE
															

	
	
	
	
#############################################	
	
	
	j END
########












END: 
	#exit program
	li $v0, 10
	syscall





#####################################################################################

Functions:


########################### Clear Screen Block ###################	
# 1.     

ClearScreenSetup:
	# Draw the Entire Screen to Black
	li $t0, BASE_ADDRESS	
	li $t7, Black
	li $t3, GBM
	move $t2, $zero
	move $t1, $t0
	
ClearScreen:
	bgt $t2, $t3, DoneClear
	
	add $t1, $t0, $t2
	sw $t7, 0($t1)
	addi $t2, $t2, 4
	
	j ClearScreen
DoneClear:
	jr $ra	
# 1. Clear Screen Function 
########################## Clear Screen FUNCTION Block ##########	




######################### CALCULATE ADDRESS FUNCTION BLOCK###########
#   2.


CalculateAddress: 
	# Take a0 = X and a1 = Y
	# Get Base Address
	li $t0, BASE_ADDRESS
	
	# offset = (Y * 64 + X )* 4
	addi $t1, $zero, 64
	mult $a1, $t1
	mflo $t1
	add $t1, $t1, $a0
	addi $t2, $zero, 4
	mult $t1, $t2
	mflo $t1
	
	add $t1, $t1, $t0
	move $v0, $t1

	jr $ra
# 2. CALCULATE ADDRESS FUNCTION
#####################################################

########### DrawEnemie Function ###########--------->
# 3. 
# This function takes 

DrawEnemie:
	
	# Push the current $ra value to the stack 
	addi $sp, $sp, -4
	sw $ra, 0($sp)

	# Get Current Base Coordinator from , and calculate Base Address (save to $t1)
	la $t0, EnemieCurrentCoordinate
	lw $t1, 0($t0)
	lw $t2, 4($t0)
	
	move $a0, $t1
	move $a1, $t2
	jal CalculateAddress
	move $t1, $v0
	
	
	# Get Colors
	li $t7, EMGrey
	li $t6, EMRed
	li $t5, EMdarkblue
	# Draw Bottom layer (1)
	sw $t7, 0($t1)
	sw $t7, 8($t1)
	sw $t7, 12($t1)
	sw $t7, -8($t1)
	sw $t7, -12($t1)
	sw $t5, 4($t1)
	sw $t5, -4($t1)
	# Draw Layer (2)
	sw $t6, -252($t1)
	sw $t6, -260($t1)
	sw $t7, -248($t1)
	sw $t7, -264($t1)
	#  lw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t7, -516($t1)
	sw $t7, -508($t1)
	#lw $t7, 0($t1)     Black no need to draw
	
	# Draw Layer (4)
	sw $t7, -768($t1)
	
# Get(pop) the stored $ra from the stack
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	
	
	# Jump Back to Caller
	jr $ra

	
# 3.			
################ The Draw Enemie Function <-------------------------------

######### Erase Enemie Function ######---------------->
#4. 
EraseCurrentEnemie:
	# Push the current $ra value to the stack 
	addi $sp, $sp, -4
	sw $ra, 0($sp)

	# Get Current Base Coordinator from , and calculate Base Address (save to $t1)
	la $t0, EnemieCurrentCoordinate
	lw $t1, 0($t0)
	lw $t2, 4($t0)
	
	move $a0, $t1
	move $a1, $t2
	jal CalculateAddress
	move $t1, $v0
	
	# t1 be the base address
	li $t6, Black
	# Erase Bottom layer (1)
	sw $t6, 0($t1)
	sw $t6, 8($t1)
	sw $t6, 12($t1)
	sw $t6, -8($t1)
	sw $t6, -12($t1)
	sw $t6, 4($t1)
	sw $t6, -4($t1)
	# Erase Layer (2)
	sw $t6, -252($t1)
	sw $t6, -260($t1)
	sw $t6, -248($t1)
	sw $t6, -264($t1)
	#  sw $t7, 0($t1)   Black no need to draw
	
	# Draw Layer (3)
	sw $t6, -516($t1)
	sw $t6, -508($t1)
	#s w$t7, 0($t1)     Black no need to draw
	
	# Erase Layer (4)
	sw $t6, -768($t1)
	
	# Get(pop) the stored $ra from the stack
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	
	# jump back to caller
	jr $ra

#4.
###################    Erase Enemie Function <-----------------------

#########  Main Character Drawing Function #########################----->
# 5. 	
DrawCharacter: 
	# Push the Current $ra to the stack
	addi $sp, $sp, -4
	sw $ra, 0($sp)

	la $t1, MainCharacterCurrentCoordinate
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t2, $v0

	# t2 as the base address	
	
	
	li $t5, CRLightBlue
	li $t6, CRLightGreen
	
	# Draw Middle Line
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t6, -1024($t2)
	sw $t6, -1280($t2)
	sw $t6, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t6, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t6, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	
	# Pop the $ra from the stack
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	
	# Back to caller
	jr $ra
# 5. 	
######################################################<------------Main Character Drawing Function

########### Erase Main Character #########################
# 6. 
EraseMainCharacter: 
	# t2 as the base address	
	
	# Push the Current $ra to the stack
	addi $sp, $sp, -4
	sw $ra, 0($sp)

	la $t1, MainCharacterCurrentCoordinate
	lw $t2, 0($t1)
	lw $t3, 4($t1)
	
	move $a0, $t2
	move $a1, $t3
	jal CalculateAddress
	move $t2, $v0

	# t2 as the base address	
	# Draw Middle Line
	li $t5, Black
	sw $t5, 0($t2)
	sw $t5, -256($t2)
	sw $t5, -512($t2)
	sw $t5, -768($t2)
	sw $t5, -1024($t2)
	sw $t5, -1280($t2)
	sw $t5, -1536($t2)
	sw $t5, -1792($t2)
	sw $t5, -2048($t2)
	
	sw $t5, 4($t2)
	sw $t5, -772($t2)
	sw $t5, -1276($t2)
	sw $t5, -1540($t2)
	sw $t5, -1796($t2)
	
	sw $t5, -4($t2)
	sw $t5, -764($t2)
	sw $t5, -1284($t2)
	sw $t5, -1532($t2)
	sw $t5, -1788($t2)
	
	# Finish Drawing
	
	# Pop the $ra from the stack
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	
	jr $ra
# 6. 
############################# Erase MainCharacter <--------------

################### Draw Pick Up Function  ################
# 7. 







# 7. 
########################################

######################## Erase Pick Up Function ###################
# 8.







# 8.
##################################################################

################### Fill Score Box Function #######################
# 9. 


# Check which score box to fill by Check NumCollected
# then choose the correct coordinate 
# calculate address and start filling


	# FillScoreBox1Coordinate





# 9. 
####3######################### Fill Score Box <-------------------

########### DrawMovingPlatformFUNCTION --------------------->
# 10. 




	


# 10.
############################### DrawMovingPlatformFunction <-----------------

########### EraseMovingPlatformFUNCTION --------------------->
# 11. 





# 11.
############################### EraseMovingPlatformFunction <-----------------





# Finished Draw Main Game Functions

# Signal and Control Functions Starts Here


###########  --------------------->
# 12. 





# 12.
###############################      <-----------------




























