#####################################################################
#
# CSCB58 Winter 2024 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yue Li, 1004746091, liyue42, yuee.li@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4 (update this as needed)
# - Unit height in pixels: 4 (update this as needed)
# - Display width in pixels: 256 (update this as needed)
# - Display height in pixels: 256 (update this as needed)
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestones have been reached in this submission?
# (See the assignment handout for descriptions of the milestones)
# - Milestone 1/2/3/4 (choose the one the applies)
#
# Which approved features have been implemented for milestone 3?
# (See the assignment handout for the list of additional features)	5 minimum

#######
# 1. Moving objects (2 marks) 
#	[enemies patrol left and right across on the platform they are on; object pickups hovering gently up and down]
# 2. Moving platforms (2 marks)
# 3. Disappearing platforms (1 mark, 2 marks max if combining with moving platforms feature)
# 4. (different levels (2 marks)  [different configuration of platforms, enemies, and pickups, at least 3 levels]
# 	[Finishing a level” depends on your game design, for example:
#		collecting all pick-ups, killing all enemies, or reaching a specific platform]
# 5. Pick-up effects (2 marks): 
#	 Make the player jump higher? Make enemies bigger? Restore player health? 
#	Turn the player into a frog? Anything goes as long as at least 3 different effects. 
# 6. Double jump (1 mark): 
#	allow the player to jump when in mid-air, but only once!
# 7. start menu (1 mark)
#	[needs to be sophisticated enough]
#
#
# Link to video demonstration for final submission:
# - (insert YouTube / MyMedia / other URL here). Make sure we can view it!
#
# Are you OK with us sharing the video with people outside course staff?
# - yes / no / yes, and please share this project github link as well!
#
# Any additional information that the TA needs to know:
# - (write here, if any)
#
#####################################################################


# The assembly directive .eqv defines a numeric constant which you can use instead of writing the
# number manually (similar to #define in C, but much more primitive) You can use it to define
# common useful constants such as fixed addresses, colours, number of enemies, etc.








.eqv BASE_ADDRESS 0x10008000

#  Each 4-byte value has the following structure: 0x00RRGGBB, where 00 are just zeros, RR is
# an 8-bit colour value for the red component, GG are the 8-bits for the green components, and BB are
# the 8-bits for the blue component. For example, 0x00000000 is black,0x00ff0000 is bright red,
# 0x0000ff00 is green, and 0x00ffff00 is yellow


.eqv Orange 0x00ff7e00
.eqv Pink 0x00ffa3b1
.eqv Green 0x00a8e61d
.eqv Black 0x00000000
.eqv 
.eqv 
.eqv 
.eqv 


.eqv Sleeptime 40

.eqv NumEnemies 1
.eqv NumPickUps 3
.eqv 
.eqv 


#####
.data




####
.text 
.globl main

main:
	
ClearScreen:
InitializeState:

mainLoop:
# for each iteration: 

#• Check for keyboard input.

#• Figure out if the player character is standing on a platform.

#• Update player location, enemies, platforms, power ups, etc.

#• Check for various collisions (e.g., between playerand enemies).

#• Update other game state and end of game.

#• Erase objects from the old position on the screen.

#• Redraw objects in the new position on the screen.

# sleep for a short time and loop again...









Check_Keyboard_input:
	li $t9, 0xffff0000	
	lw $t8, 0($t9)
	beq $t8, 1, keypress_happened

keypress_happened:
	lw $t2, 4($t9) 			# this assumes $t9 is set to 0xfff0000 from before
	beq $t2, 0x77, respond_to_w 	# ASCII code of 'w' is 0x77 or 119 in decimal
	beq $t2, 0x61, respond_to_a 	# ASCII code of 'a' is 0x61 or 97 in decimal
	beq $t2, 0x73, respond_to_s 	# ASCII code of 's' is 0x73 or 115 in decimal
	beq $t2, 0x64, respond_to_d 	# ASCII code of 'd' is 0x64 or 100 in decimal
	beq $t2, 0x72, Restart 		# ASCII code of 'r' is 0x72 or 114 in decimal
	beq $t2, 0x71, QuitGame 	# ASCII code of 'q' is 0x71 or 113 in decimal
	# in the case of capital letters
	beq $t2, 0x57, respond_to_w 	# ASCII code of 'W' is 0x57 or 87 in decimal
	beq $t2, 0x41, respond_to_a 	# ASCII code of 'A' is 0x41 or 65 in decimal
	beq $t2, 0x53, respond_to_s 	# ASCII code of 'S' is 0x53 or 83 in decimal
	beq $t2, 0x44, respond_to_d 	# ASCII code of 'D' is 0x44 or 68 in decimal
	beq $t2, 0x52, Restart 		# ASCII code of 'R' is 0x52 or 82 in decimal
	beq $t2, 0x51, QuitGame 	# ASCII code of 'Q' is 0x51 or 81 in decimal

END: 
	#exit program
	li $v0, 10
	syscall








respond_to_w:
respond_to_a:
respond_to_s:	
respond_to_d:
Restart:
QuitGame:

DrawInitialScreen:
	


RandomNumberGenerator:
	li $v0, 42
	li $a0, 0
	li $a1, 28
	syscall

	
# For animations, we generally need to update the display between 20 to 60 times per second (we
# recommend sleeping for 40ms, at least initially, which is a 25Hz update rate). When developing your
# game, you may find it occasionally useful to set it to a very high number to help debugging. We
# recommend using a constant (.eqv) to make it easy to change the wait time.	

SleepOperation:
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall


# Game State Logic:
# 1. Initialize (Draw initial screen, set character and objects state, start main loop)
# 2. Ongoing	
# 3. Collision with enemy: -> Draw Game over Screen (State -> take r and q input, show score)
# 4. Restart -> initialize
# 5. Collected three pick-ups -> Draw you win Screen (take r and q input, show score)
# 6. Quit -> exit program (END)














