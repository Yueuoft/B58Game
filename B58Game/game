#####################################################################
#
# CSCB58 Winter 2024 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yue Li, 1004746091, liyue42, yuee.li@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4 (update this as needed)
# - Unit height in pixels: 4 (update this as needed)
# - Display width in pixels: 256 (update this as needed)
# - Display height in pixels: 256 (update this as needed)
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestones have been reached in this submission?
# (See the assignment handout for descriptions of the milestones)
# - Milestone 1/2/3/4 (choose the one the applies)
#
# Which approved features have been implemented for milestone 3?
# (See the assignment handout for the list of additional features)	5 minimum

#######
# 1. Moving objects (2 marks) 
#	[enemies patrol left and right across on the platform they are on; object pickups hovering gently up and down]
# 2. Moving platforms (2 marks)
# 3. Disappearing platforms (1 mark, 2 marks max if combining with moving platforms feature)
# 4. (different levels (2 marks)  [different configuration of platforms, enemies, and pickups, at least 3 levels]
# 	[Finishing a level” depends on your game design, for example:
#		collecting all pick-ups, killing all enemies, or reaching a specific platform]
# 5. Pick-up effects (2 marks): 
#	 Make the player jump higher? Make enemies bigger? Restore player health? 
#	Turn the player into a frog? Anything goes as long as at least 3 different effects. 
# 6. Double jump (1 mark): 
#	allow the player to jump when in mid-air, but only once!
# 7. start menu (1 mark)
#	[needs to be sophisticated enough]
#
#
# Link to video demonstration for final submission:
# - (insert YouTube / MyMedia / other URL here). Make sure we can view it!
#
# Are you OK with us sharing the video with people outside course staff?
# - yes / no / yes, and please share this project github link as well!
#
# Any additional information that the TA needs to know:
# - (write here, if any)
#
#####################################################################


# The assembly directive .eqv defines a numeric constant which you can use instead of writing the
# number manually (similar to #define in C, but much more primitive) You can use it to define
# common useful constants such as fixed addresses, colours, number of enemies, etc.








.eqv BASE_ADDRESS 	0x10008000

#  Each 4-byte value has the following structure: 0x00RRGGBB, where 00 are just zeros, RR is
# an 8-bit colour value for the red component, GG are the 8-bits for the green components, and BB are
# the 8-bits for the blue component. For example, 0x00000000 is black,0x00ff0000 is bright red,
# 0x0000ff00 is green, and 0x00ffff00 is yellow


.eqv Orange 				0x00ff7e00
.eqv BoundaryPink 			0x00ffa3b1
.eqv PlatformGreen 			0x00a8e61d
.eqv Black 				0x00000000
.eqv Yellow 				0x00fff200
.eqv CRLightBlue 			0x0099d9ea
.eqv CRLightGreen 			0x00d3f9bc
.eqv CRDarkGreen			0x0022b14c
.eqv EMGrey				0x00546d8e
.eqv EMRed				0x00ed1c24
.eqv EMdarkblue				0x002f3699


.eqv Sleeptime 	40

.eqv NumEnemies 		1
.eqv NumPickUps 		3
.eqv JumpHeight			13	# units
.eqv MaxTimeJumped		2	# time before Collide with platform
.eqv FallingRate		1
.eqv JumpRate			13
.eqv platformMovingRate		1	#unitFrameBuffer
.eqv EnemieMovingRate		1
.eqv MainCharacterMovingRate	2
.eqv PickUpHoverRate		1


.eqv HeightofMainCharacter	9



.eqv RowUnit		64
.eqv LBM 		16128		#256 * 64 = 16384 or (62*64+0)*4
.eqv RBM		16124		#(62*64+63)*4 = 16380 





#####
.data

# NumCollected 	.word 	0
# NumFilled	.word	0
# NumJumped	.word	0




####
.text 
.globl main

main:
	# Draw the Upper Boundary to Pink
	li $t0, BASE_ADDRESS	
	li $t1, BoundaryPink
	# let t2 be the current address
	move $t2, $t0
	# endpoint for upper boundary painting
	addi $t3, $t2, 256
	# endpoint for left boundary painting	256 * 64 = 16384
	addi $t4, $t0, LBM
	# endpoint for right boundary painting
	addi $t5, $t0, RBM
PaintUpperBoundary:
	beq $t2, $t3, PaintLeftBoundary
	sw $t1, 0($t2) 	# paint the first (top-left) unit pink
	
	addi $t2, $t2, 4
	j PaintUpperBoundary
	
PaintLeftBoundary:
	# $t2 = $t0 + 256 at this time
	beq $t2, $t4, PaintRightBoundaryInitial
	sw $t1, 0($t2)			# paint row 1 column 0 to pink
	addi $t2, $t2, 256
	j PaintLeftBoundary

PaintRightBoundaryInitial:
	# $t2 = $t0 + LBM at this time 
	
	add $t2, $t0, 252
	
PaintRightBoundary:
	
	sw $t1, 0($t2)
	beq $t2, $t5, END
	addi $t2, $t2, 256
	
	j PaintRightBoundary
				
PaintGround:
	
		
			
				
						
	
	
	
ClearScreen:
	# Draw the Entire Screen to Black
	li $t0, BASE_ADDRESS	
	li $t1, Black
	
	
	
InitializeState:
	# DrawInitialScreen
	
	# DrawBottomPlatform
	li $t0, BASE_ADDRESS	
	li $t1, PlatformGreen
	
	
	
	
	

mainLoop:
# for each iteration: 

#• Check for keyboard input.

#• Figure out if the player character is standing on a platform.

#• Update player location, enemies, platforms, power ups, etc.

#• Check for various collisions (e.g., between playerand enemies).

#• Update other game state and end of game.

#• Erase objects from the old position on the screen.

#• Redraw objects in the new position on the screen.

# sleep for a short time and loop again...









Check_Keyboard_input:
	li $t9, 0xffff0000	
	lw $t8, 0($t9)
	beq $t8, 1, keypress_happened

keypress_happened:
	lw $t2, 4($t9) 			# this assumes $t9 is set to 0xfff0000 from before
	beq $t2, 0x77, respond_to_w 	# ASCII code of 'w' is 0x77 or 119 in decimal
	beq $t2, 0x61, respond_to_a 	# ASCII code of 'a' is 0x61 or 97 in decimal
	beq $t2, 0x73, respond_to_s 	# ASCII code of 's' is 0x73 or 115 in decimal
	beq $t2, 0x64, respond_to_d 	# ASCII code of 'd' is 0x64 or 100 in decimal
	beq $t2, 0x72, Restart 		# ASCII code of 'r' is 0x72 or 114 in decimal
	beq $t2, 0x71, QuitGame 	# ASCII code of 'q' is 0x71 or 113 in decimal
	# in the case of capital letters
	beq $t2, 0x57, respond_to_w 	# ASCII code of 'W' is 0x57 or 87 in decimal
	beq $t2, 0x41, respond_to_a 	# ASCII code of 'A' is 0x41 or 65 in decimal
	beq $t2, 0x53, respond_to_s 	# ASCII code of 'S' is 0x53 or 83 in decimal
	beq $t2, 0x44, respond_to_d 	# ASCII code of 'D' is 0x44 or 68 in decimal
	beq $t2, 0x52, Restart 		# ASCII code of 'R' is 0x52 or 82 in decimal
	beq $t2, 0x51, QuitGame 	# ASCII code of 'Q' is 0x51 or 81 in decimal

END: 
	#exit program
	li $v0, 10
	syscall








respond_to_w:
respond_to_a:
respond_to_s:	
respond_to_d:
Restart:
QuitGame:

DrawInitialScreen:
	# Draw Bottom Platform
	


RandomNumberGenerator:
	li $v0, 42
	li $a0, 0
	li $a1, 28
	syscall

	
# For animations, we generally need to update the display between 20 to 60 times per second (we
# recommend sleeping for 40ms, at least initially, which is a 25Hz update rate). When developing your
# game, you may find it occasionally useful to set it to a very high number to help debugging. We
# recommend using a constant (.eqv) to make it easy to change the wait time.	

SleepOperation:
	li $v0, 32
	li $a0, Sleeptime			# Wait one second (1000 milliseconds)
	syscall


# Game State Logic:
# 1. Initialize (Draw initial screen, set character and objects state, start main loop)
# 2. Ongoing	
# 3. Collision with enemy: -> Draw Game over Screen (State -> take r and q input, display NumCollected )
# 4. Restart -> initialize
# 5. NumFilled == 3  -> Draw you win Screen (take r and q input, display NumCollected)
# 6. Quit -> exit program (END)



FillScoreSquare:
	





DrawCharacter:




DrawEnemie:





DrawPickup:






DrawMovingPlatform:



DrawBottomPlatform:


DrawMiddlePlatform:




DrawYouWinScreen:




DrawGameOverScreen:




# JumpHeight

# Collide with ground



##
#	Enemie State:
#	1. Initial
#	2. Patrol left -> (detect Wall) -> 3
#		Patrol left -> Collision with MainCharacter -> GameOver
#	3. Patrol right -> (detect Wall) ->2
#		Patrol right -> Collision with MainCharacter -> Gameover



##
#	PickUp State:
#	1. initial State
#	2. Hover Up -> 3
#		Hover Up -> (Collision with MainCharacter -> 4)
#	3. Hover Down - > 2
#		Hover Down -> (Collision with MainCharacter -> 4)
#	4. Disappear (Erase) ---> Score +1 --> Fill ScoreSquare 
#		



## 
#	ScoreSquare State:
#	1. NumFilled == 0
#	2. NumFilled == 1
#	3. NumFilled == 2
#	4. NumFilled == 3 ---> You Win State, display score
#
#


##	
#	MovingPlatformState:
#	1. Initial State == initial address
#	2. MovingLeft --> move with movingRate
#	3. MovingRight ---> move with MovingRate
#	4. Steady state
#


##
#	MainCharacterState:
#	1. InitialState == initial address + initialDraw
#	2. SteadyState
#	3. MoveLeft
#	4. MoveRight 
#	5. Jumping	CurrentAddress + jumprate
#	6. DoubleJump   CurrentAddress + jumpRate
#	7. FallingState
#	8. CollideWithPlatform --> 2. steadyState
#	9. CollideWithEnemie --> ChangeColorVariation(TurnRed) + GameOverState
#	10. CollideWithPickUps ---> ChangeColorVariation(TurnYellow) ---> ChangeColorBack+ steady?
#

# MovingPlatform to top = 36 units 27 /2 = 13 
# height of main character = 9 units
# 













